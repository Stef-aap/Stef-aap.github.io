<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="author" content="Stef Mientki">
   <meta name="generator" content="Mozilla/4.7 [en-gb] (Win98; U) [Netscape]">
   <title>Universal_Control_Box</title>
</head>
<body text="#000000" bgcolor="#FFFF00" link="#0000EE" vlink="#551A8B" alink="#FF0000">
&nbsp;
<table WIDTH="100%" >
<tr>
<td ALIGN=CENTER><a name="top"></a><font face="Arial,Helvetica"><a href="../lego_mindstorms_knex_index.html">Lego-Knex</a></font>
<br><font face="Arial,Helvetica"><a href="../../robbert/robbert_home.html">Robbert</a></font>
<br><font face="Arial,Helvetica"><a href="../../mattijs/mattijs_home.html">Mattijs</a></font>
<br><a href="mailto:s.mientki@ids.kun.nl"><img src="mail.gif" height=18 width=29></a>
<br><font face="Arial,Helvetica"><a href="switch_multiplexer.html">multiplexer
overview</a></font></td>

<td ALIGN=CENTER><b><font size=+3>Mindstorms Universal Control Box</font></b>
<br><font size=+2>Stef Mientki</font>
<br><font size=-1>april 2001</font></td>

<td ALIGN=CENTER VALIGN=TOP><font face="Arial,Helvetica"><a href="#features">Features</a></font>
<br><font face="Arial,Helvetica"><a href="#principle of time multiplexing">Time
Multiplexing</a></font>
<br><font face="Arial,Helvetica"><a href="#amplitude multiplexing">Amplitude
Multiplexing</a></font>
<br><font face="Arial,Helvetica"><a href="#power supply + puls detection">Pulse
Detection</a></font>
<br><font face="Arial,Helvetica"><a href="#status leds">Status LEDs</a></font>
<br><font face="Arial,Helvetica"><a href="#programming">Programming</a></font>
<br><font face="Arial,Helvetica"><a href="#what didn't work">What doesn't
work</a></font></td>
</tr>
</table>

<br>&nbsp;
<table BORDER WIDTH="100%" >
<tr>
<td COLSPAN="2">
<center><b><font face="Arial,Helvetica"><font color="#3333FF">Sensor Multiplexer,&nbsp;</font></font></b>
<br><b><font face="Arial,Helvetica"><font color="#3333FF">uses both time
and amplitude multiplexing</font></font></b></center>
</td>
</tr>

<tr>
<td><a name="features"></a><b><font face="Arial,Helvetica"><font color="#3333FF">Features&nbsp;</font></font></b><a href="#top"><img src="top_page.gif" height=14 width=14></a>
<ul>
<li>
<font face="Arial,Helvetica">3 potmeters</font></li>

<li>
<font face="Arial,Helvetica">10 switches</font></li>

<li>
<font face="Arial,Helvetica">3 external analog inputs</font></li>

<li>
<font face="Arial,Helvetica">3 status LEDs</font></li>

<li>
<font face="Arial,Helvetica">test terminals</font></li>
</ul>
<font face="Arial,Helvetica">Our special interest was to build a controlbox,
which could be used during experiments and prototyping&nbsp; without the
need to use a computer all the time&nbsp; to program the RCX.</font>
<br><font face="Arial,Helvetica">So we intended the potmeters to control
the 3 motors, forward / backward and power control. Three of the switches
were intended as motor float switches. The function of the other switches
have no fixed meaning, neither have the status LEDs.</font>
<br><font face="Arial,Helvetica">The spare analog inputs are meant to test
new sensors.</font>
<p><font face="Arial,Helvetica">The RCXcc program (NQC) can be downloaded
<a href="test_ucb.nqc">here</a>.</font>
<p><font face="Arial,Helvetica">All measurements were done with</font>
<ul>
<li>
<font face="Arial,Helvetica">Mindstorms 1.0</font></li>

<li>
<font face="Arial,Helvetica">RIS 1.5</font></li>

<li>
<font face="Arial,Helvetica">NiCd batteries</font></li>

<li>
<font face="Arial,Helvetica">RCXcc programming</font></li>
</ul>
</td>

<td>
<center><img src="contorlbox_front.jpg" height=443 width=319></center>
</td>
</tr>

<tr>
<td><a name="principle of time multiplexing"></a><b><font face="Arial,Helvetica"><font color="#3333FF">Principle
of time multiplexing&nbsp;</font></font></b><a href="#top"><img src="top_page.gif" height=14 width=14></a>
<p><font face="Arial,Helvetica">Time multiplexing is done by a cheap 1
to 8 analog mux (4051) and a 4 bits counter (4520). The counter is controled
by 2 signals, the clock-signal and the reset-signal. Both these signals
are generated by the RCX by going into touch-sensor mode for a short period
of time. By using different time periods, you can create distinguishable
signals.</font></td>

<td>
<center><img src="control_box_principle.jpg" height=324 width=411></center>
</td>
</tr>

<tr>
<td><font face="Arial,Helvetica">On the right a simulation (close resemblance
to oscilloscope measurements) of pulses</font>
<p><font face="Arial,Helvetica">The "measurement pulse" is generated by
the RCX for the measurement of the light sensor.&nbsp;</font>
<p><font face="Arial,Helvetica">An instruction to go into touch-sensor
mode, followed directly by an instruction to go back into light-sensor
mode, will give a passive (10 kOhm pulled-up to + 5V) pulse of&nbsp; 6
msec. This will be detected by the cirquit as a clock pulse for the counter.</font>
<p><font face="Arial,Helvetica">Giving an instructions to go into touch
mode, wait for 20 msec, followed by an instruction to back into light-sensor
mode, will give a passive sensor input of 20 msec. This pulse will be detected
as a counter reset.</font>
<p><font face="Arial,Helvetica">&nbsp;</font></td>

<td>
<center><img src="puls_coding.jpg" height=340 width=474></center>
</td>
</tr>
</table>

<br>&nbsp;
<br>&nbsp;
<p><a name="power supply + puls detection"></a><b><font face="Arial,Helvetica"><font color="#3333FF">Power
Supply + pulse detection&nbsp;</font></font></b><a href="#top"><img src="top_page.gif" height=14 width=14></a>
<br>&nbsp;
<table BORDER WIDTH="100%" >
<tr>
<td><font face="Arial,Helvetica"><b><font color="#3333FF">Power</font></b>
is derived in the classical way by 4 diodes (D1..D4) and a capacitor C1.
Because relative large periods (40 msec) the sensor will be switched to
touch-sensor and due to the experimental usage of this cirquit, a large
capacitor is needed. Because I had space enough, I even used 1000 uF, which
is well overdone in most cases.</font>
<p><font face="Arial,Helvetica"><b><font color="#3333FF">The clock pulse</font></b>
is derived with a simple RC-network R4,C2) and separate diodes (D7,D8).
Special thanks to Nitin Patil, who suggested to use a zenerdiode. Not using
a zener diode, R4 should be about 1 kOhm (and C2 should be 1 uF), to get
the amplitude low enough, which will lead to a needless energy consumption.
For the status LEDs we needed an inverted clock pulse. Therefor we used
the 2 transistors Q2 and Q3 to get the 2 different clock-pulses. When the
transistor Q2 starts to go in the off-state, resistor R5 ensures that capacitor
C2 will be full decharged and the transistor will really go in the off-state,
generating a positive pulse on his collector.&nbsp;</font>
<p><font face="Arial,Helvetica">This RC-network will suppress the light
measuring pulses and will detect a touch-sensor mode pulse longer than
1 msec.</font>
<p><font face="Arial,Helvetica"><b><font color="#3333FF">The reset pulse</font></b>
is derived with D9,R12 and C3, while will supress touch-sensor pulses shorter
than 10 msec.</font>
<p><font face="Arial,Helvetica"><b><font color="#3333FF">Signal generation</font></b>
is done by a voltage drive, implemented by U1A and R3. The resistor R3
is made as low as possible to get the most linearity from a voltage drive.
A good linearity is required to realize the amplitude multi-plexing up
to 5 switches. A current drive is in this cirquit not possible, see notes
below.</font>
<br><font face="Arial,Helvetica">With the input of the voltage drive ranging
from 0 ... 2 Volt, the RCX raw values will range from 315 ... 1010.</font></td>

<td><img src="control_box_power.jpg" height=494 width=448></td>
</tr>
</table>

<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<table BORDER WIDTH="100%" >
<tr>
<td><a name="stable voltage reference"></a><b><font face="Arial,Helvetica"><font color="#3333FF">Stable
Voltage Reference&nbsp;</font></font></b><a href="#top"><img src="top_page.gif" height=14 width=14></a>
<p><font face="Arial,Helvetica"><font color="#000000">Because there was
one half of the dual opamp left, we used it to generate a stable Voltage
reference for use in generating the analog signals.</font></font>
<br>&nbsp;
<br>&nbsp;
<p><font face="Arial,Helvetica"><font color="#000000">On the left the test
connector for new sensors is drawn.</font></font></td>

<td><img src="control_box_vref.jpg" height=304 width=462></td>
</tr>
</table>

<br>&nbsp;
<p><a name="time multiplexing and status leds"></a><b><font face="Arial,Helvetica"><font color="#3333FF">Time
Multiplexing and Status LEDs&nbsp;</font></font></b><a href="#top"><img src="top_page.gif" height=14 width=14></a>
<br><font face="Arial,Helvetica">The clock pulses are counted with a binairy
counter (4520) and the lower 3 bits of the counter directly control the
analog multiplexer (4051), which will connect one of the IO-pins&nbsp;
(X0..X7) to the common-IO-pin (X).</font>
<br>&nbsp;
<p><a name="status leds"></a><b><font face="Arial,Helvetica"><font color="#3333FF">Status
LEDs</font></font></b>
<br><font face="Arial,Helvetica">Because a 4 bit counter (half of the 4520)
was left unused, we've tried to give it a useful destination. With a transistor
and some diodes we managed to create a status led multiplexer. The principle
is as follows:</font>
<br><font face="Arial,Helvetica">The LED's are connected to the outputs
of the 4-bit binairy counter U3B, which merely has a memory function (flip-flop).
Normally the counter U3A will only count from 0 to maximal 7&nbsp; (to
measure all eight analog signals) and thus leaving the status of the LED's
unchanged (because counter U3B is disabled by the MSB of U3A, counter values
8..15).</font>
<br><font face="Arial,Helvetica">If now still more clock pulses is generated,
first U3B will be reset by the counter value 8 / 1000 on the outputs of
U3A. On every next clock pulses, the counter U3B will advance one step.</font>
<br><font face="Arial,Helvetica">Because we needed countvalue 8 for other
purposes only three LEDs can be used in this design.</font>
<p><font face="Arial,Helvetica">This is a nice example of using a sensor
input as an multiplexed actuator output, which can be used in general as
long as the actuators are using not too much current.</font>
<center><img src="control_box_encoder.jpg" height=402 width=667></center>

<p><br>
<br>
<br>
<br>
<p><a name="amplitude multiplexing"></a><b><font face="Arial,Helvetica"><font color="#3333FF">Amplitude
Multiplexing&nbsp;</font></font></b><a href="#top"><img src="top_page.gif" height=14 width=14></a>
<br><font face="Arial,Helvetica">As can be seen in the schematic below,
the potmeters (placed between ground and Vref) can be connected directly
to input of the multiplexer, whereby the linearity is only determined by
the voltage-drive cirquit.</font>
<p><font face="Arial,Helvetica">Analog signals in the range of&nbsp; 0..
2 Volt also can be directly tied to an input of the multiplexer.</font>
<p><font face="Arial,Helvetica">Amplitude-multiplexing upto 5 switches
requires a current source, to get a very linear respons, which is necessairy
to detect the individual switches. First a stable voltage (in respect to
the unstable +7 Volt) is derived with D98,D99,C99 and R99. Then transistor
Q100 and resistors R101 ... R105 will generate a stable current through
R100, resulting in the voltage to be measured. The generated current is
(for switches that are in the on-state, otherwise zero) linear depending
on</font>
<blockquote><font face="Arial,Helvetica">(1/R101) + (1/102) + ... (1/105)&nbsp;
= (1/2)+(1/4)+..+(1/32)</font></blockquote>
<font face="Arial,Helvetica">resulting in equally spaced amplitude intervals
for every binairy step. The resistors can be normally 5% types, but some
values (specially the large values) must be made up from 2 resistors, see
table below, to get enough accuracy. To fully use the range of the RCX,
R9 (see schematic above) is placed in parallel with R100.</font>
<br>As can be seen from the table, all switch combinations are good distingushable,
but looking good at the figure on the right, it's not totally linear. This
is meanly due to the voltage drive, which was needed to get a stable interfacing
of the (relative bad) multiplexer. So if you want to detect the switch
state by a simple formula, you can only distingush between 4 switches (see
programming examples below).
<br>&nbsp;
<table BORDER WIDTH="100%" >
<tr>
<td>Measurements from switch encoder
<center>
<p><img src="controlbox_switch_table.jpg" height=289 width=250></center>
</td>

<td>
<center><img src="controlbox_switch_graph.jpg" height=339 width=438></center>
</td>
</tr>
</table>

<table BORDER WIDTH="100%" >
<tr>
<td><font face="Arial,Helvetica">Combining resistors</font>
<br><font face="Arial,Helvetica">to get the good values</font>
<p><font face="Arial,Helvetica">R101 = 22k</font>
<br><font face="Arial,Helvetica">R102 = 47k</font>
<br><font face="Arial,Helvetica">R103 = 100k</font>
<br><font face="Arial,Helvetica">R104 = 200k = 100k + 100k</font>
<br><font face="Arial,Helvetica">R105 = 400k = 220k + 180k</font></td>

<td>
<center><img src="control_box_switch_encoder.jpg" height=363 width=604></center>
</td>
</tr>
</table>

<br>&nbsp;
<p><a name="programming"></a><b><font face="Arial,Helvetica"><font color="#3333FF">Programming&nbsp;</font></font></b><a href="#top"><img src="top_page.gif" height=14 width=14></a>
<br><font face="Arial,Helvetica">The complete NQC-programm (also containing
comment and several test tasks) can be downloaded <b><a href="test_ucb.nqc">here</a></b>.</font>
<br><font face="Arial,Helvetica">Here only the basic principles are shown.</font>
<table BORDER WIDTH="100%" >
<tr>
<td><font face="Arial,Helvetica">Generating the <b><font color="#3333FF">reset
pulse</font></b></font></td>

<td><font face="Arial,Helvetica">SetSensor(_S,SENSOR_LIGHT);</font>
<br><font face="Arial,Helvetica">SetSensor(_S,SENSOR_TOUCH);</font>
<br><font face="Arial,Helvetica">Wait(4);</font>
<br><font face="Arial,Helvetica">SetSensor(_S,SENSOR_LIGHT);</font></td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font color="#3333FF">Reading a signal</font></font></b></td>

<td><font face="Arial,Helvetica">SetSensorMode(_S,SENSOR_MODE_RAW);</font>
<br><font face="Arial,Helvetica">x=_S;</font></td>
</tr>

<tr>
<td><font face="Arial,Helvetica">Generating the <b><font color="#3333FF">clock
pulse</font></b>,</font>
<br><font face="Arial,Helvetica">for the next signal or LED</font></td>

<td><font face="Arial,Helvetica">SetSensor(_S,SENSOR_LIGHT);</font>
<br><font face="Arial,Helvetica">SetSensor(_S,SENSOR_TOUCH);</font>
<br><font face="Arial,Helvetica">SetSensor(_S,SENSOR_LIGHT);</font></td>
</tr>

<tr>
<td><font face="Arial,Helvetica"><b><font color="#3333FF">Encoding</font></b>
the switches</font>
<br><font face="Arial,Helvetica">because it will almost linear</font>
<br><font face="Arial,Helvetica">we can use a formula in the case of 4
switches</font></td>

<td><font face="Arial,Helvetica">x=(X4-300)*15/550</font></td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font color="#3333FF">Setting the status
LEDs</font></font></b>
<br><font face="Arial,Helvetica"><font color="#000000">(after reading all
analog signals)</font></font></td>

<td><font face="Arial,Helvetica">repeat (LED_VALUE)</font>
<br><font face="Arial,Helvetica">{</font>
<br><font face="Arial,Helvetica">&nbsp;&nbsp; SetSensor(_S,SENSOR_TOUCH);</font>
<br><font face="Arial,Helvetica">&nbsp;&nbsp; SetSensor(_S,SENSOR_LIGHT);</font>
<br><font face="Arial,Helvetica">}</font></td>
</tr>
</table>

<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<table BORDER WIDTH="100%" >
<tr>
<td COLSPAN="2">
<center><a name="what didn't work"></a><b><font face="Arial,Helvetica"><font color="#FF0000">What
didn't work&nbsp;</font></font></b><a href="#top"><img src="top_page.gif" height=14 width=14></a></center>
</td>
</tr>

<tr>
<td><a name="pulse decoding"></a><b><font face="Arial,Helvetica"><font color="#FF0000">Pulse
decoding&nbsp;</font></font></b><a href="#top"><img src="top_page.gif" height=14 width=14></a>
<p><font face="Arial,Helvetica">On the right a simulation (close resemblance
to oscilloscope measurements) of pulses at the junction of D7,D8 in the
figure below.</font>
<p><font face="Arial,Helvetica">The "measurement pulse" is generated by
the RCX for the measuremnt of the light sensor.&nbsp;</font>
<p><font face="Arial,Helvetica">An instruction to go into touch-sensor
mode, followed directly by an instruction to go back into light-sensor
mode, will give a passive (10 kOhm pulled-up to + 5V) pulse of&nbsp; 6
msec. This will be detected by the schematics below as a clock pulse for
the counter.</font>
<p><font face="Arial,Helvetica">Giving 2 consecutive instructions to go
into touch mode, directly followed by an instruction to back into light-sensor
mode, will give a passive sensor input of 12 msec. This pulse will be detected
as a counter reset.</font></td>

<td>
<center><img src="puls_coding.jpg" height=340 width=474></center>
</td>
</tr>

<tr>
<td><a name="combined pulse decoding"></a><b><font face="Arial,Helvetica"><font color="#FF0000">Combined
pulse decoding&nbsp;</font></font></b><a href="#top"><img src="top_page.gif" height=14 width=14></a>
<p><font face="Arial,Helvetica">At first the schematic on the right (theoretically
designed on the above measurements) seems to work fine. The signal to noise
ratio is quiet large and it uses a minimum of components.</font>
<p><font face="Arial,Helvetica">BUT, for some unclear reason, the pulses
are sometimes extended, and a count pulse will reset the counter. Stopping
the RCX program and restarting it, will give in 9 out of 10 cases stable
pulses. But that's not good enough.</font>
<p><font face="Arial,Helvetica">Why are some (1 of 6)&nbsp; pulses extended,
depending on the moment you start the RCX programm ???? Weird !!!</font></td>

<td>
<center><img src="puls_coding_schema.jpg" height=232 width=444></center>
</td>
</tr>

<tr>
<td><a name="current drive"></a><b><font face="Arial,Helvetica"><font color="#FF0000">Current
Drive&nbsp;</font></font></b><a href="#top"><img src="top_page.gif" height=14 width=14></a>
<p><font face="Arial,Helvetica">My favorit current drive, shown on the
right, doesn't work in this application.</font>
<p><font face="Arial,Helvetica">The reason for this&nbsp;</font>
<br><font face="Arial,Helvetica">- the bandwidth of the currentdrive cirquit
is very large, and can not easilly be made smaller</font>
<br><font face="Arial,Helvetica">- the applied multiplexer (4051) drops
a lot of charge between switching</font>
<p><font face="Arial,Helvetica">The effect is that during switching a very
large current is drawn from the RCX, and this will sometimes trigger the
counter, so we get a postive feedback.</font></td>

<td>
<center><img src="current_driven_sensor.jpg" height=284 width=391></center>
</td>
</tr>
</table>

</body>
</html>
