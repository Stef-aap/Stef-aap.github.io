<html>
<head>
<title>JALcc SourceCode exporting of rs232_hw_source.html</title>
</head>
<!-- Generated by SynEdit HTML exporter -->
<body text="#000000" bgcolor="#FFFFFF">
<pre>
<code><font  size=3 face="Courier New"><font color="#000080"><A href="rs232_hw.jal">download&nbsp;rs232_hw.jal</A>
</font><font color="#808080"><i>-- -----------------------------------------------------------------------------
-- &lt;title USART hardware control
-- &lt;License
-- freeware, under the terms of the GNU GPL
--  Copyright (C) 2002 Stef Mientki
-- -----------------------------------------------------------------------------
-- &lt;Description
-- USART hardware control.
--  Routines for sending and receiving through the PIC-usart,
-- both RS232 and SPI are supported
--  Baudrate can simply be set through a human constant,
-- because the baudrate depending registers are calculated by this unit.
--  Baudrate is calculated, starting at the high baudrate flag,
-- which will ensure the highest possible accuracy.
--  SPI routines are setup for more SPI-devices,
-- in which case CS should be controled outside this unit.
--  Transmission parameters are 8 databits, 1 stopbit, no parity, no handshake.
--
-- &lt;non-tag
-- procedure SPI_init is
-- procedure asynch_init_hw is
-- procedure asynch_disable_hw
-- procedure asynch_send_hw( byte in x ) is
-- function  asynch_read_hw( byte out x ) return bit is
-- procedure SPI_send_hw( byte in x ) is
-- procedure SPI_read_hw( byte out x ) is
--
-- &lt;Version: 3.0    ,21-08-2002, Stef Mientki
--   - INTCON clearing removed, blocked all interrupts,
--     instead PIE bits cleared to prevent USART interrupts
--
-- &lt;Version: 2.0    ,21-06-2002, Stef Mientki
--   - added Procedure ASYNCH_DISABLE_HW
--
-- &lt;Version: 1.0    ,17-03-2002, Stef Mientki
--   - original release
-- --------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- &lt;Example RS232
; -- define settings
; const usart_asynch = true      ;true = RS232, false = SPI
; const baudrate     = 115_200   ;Baudrate
;
; var byte xx
; forever loop
;   -- if character received, echo inverted
;   if asynch_read_hw (xx) then
;     asynch_send_hw ( ! xx)
;   end if
;   ... do other things here
; end loop
-- -----------------------------------------------------------------------------


-- &lt;code

-- --------------------------------------------------------------------
-- internal function, calculates and sets baudrate divider
-- and stores it in the appropiate register.
-- the high-speed / low-speed bit is not stored but returned as the result
--
-- Special attention is payed to the highest and lowest baudrates,
-- a deviation of 5% is accepted in these cases
--
-- Asynchronuous baudrate settings (see also page 74/75 of DS40300B)
--
-- if BRGH = 0 (low speed)
--  SPBRG = ( Fosc / ( 64 * Baudrate ) ) -1
--
-- if BRGH = 1 (high speed)
--  SPBRG = ( Fosc / ( 16 * Baudrate ) ) -1
--
-- Synchronous baudrate settings
-- BRGH = 0 (low speed)
--  SPBRG = ( Fosc / ( 4 * Baudrate ) ) -1
-- --------------------------------------------------------------------
</i></font><b>procedure </b><font color="#000080">_calculate_and_set_Baudrate </font><b>is
  const </b><font color="#FF0000">max_deviation </font><font color="#000080"><b>= </b></font><font color="#FF0000">5  </font><font color="#808080"><i>-- maximum % deviation of the realized baudrate
  </i></font><b>var bit </b><font color="#000080">baudrate_high
</font><font color="#808080"><i>;var byte var1
;var bit baudrate_high at var1 : BRGH

  </i></font><b>if </b><font color="#FF0000">usart_asynch </font><b>then

    </b><font color="#808080"><i>-- first try high baudrate, will generate highest accuarcy
    -- to get the right rounding (5 + 10*f(x)) /10
    </i></font><b>const </b><font color="#FF0000">usart_div </font><font color="#000080"><b>= ((</b></font><font color="#FF0000">5 </font><font color="#000080"><b>+ ( ( </b></font><font color="#FF0000">10 </font><font color="#000080"><b>* </b>target_clock <b>) / ( </b></font><font color="#FF0000">16 </font><font color="#000080"><b>* </b></font><font color="#FF0000">baudrate </font><font color="#000080"><b>))  ) / </b></font><font color="#FF0000">10 </font><font color="#000080"><b>) - </b></font><font color="#FF0000">1


</font><font color="#808080"><i>;var byte aaap
    -- special case if divider is 0,
    -- test if deviation is not too much
    </i></font><b>if </b><font color="#FF0000">usart_div </font><font color="#000080"><b>&lt;= </b></font><font color="#FF0000">0 </font><b>then
      if </b><font color="#000080"><b>(</b></font><font color="#FF0000">100 </font><font color="#000080"><b>* (</b></font><font color="#FF0000">baudrate </font><font color="#000080"><b>- (</b>target_clock <b>/ </b></font><font color="#FF0000">16</font><font color="#000080"><b>) )) / </b></font><font color="#FF0000">baudrate </font><font color="#000080"><b>&gt;= </b></font><font color="#FF0000">max_deviation </font><b>then
        </b><font color="#800080"><i>pragma </i></font><b>error  </b><font color="#808080"><i>-- asynchronous baudrate is too high
      </i></font><b>end if
    end if

</b><font color="#808080"><i>;aaap = usart_div
;pragma test assert  aaap == 10
;pragma test assert SPBRG == 10
;pragma test done
    -- if divider small enough,
    -- calculate divider and set high-speed
    </i></font><b>if </b><font color="#FF0000">usart_div </font><font color="#000080"><b>&lt;= </b></font><font color="#FF0000">255 </font><b>then
      if </b><font color="#FF0000">usart_div </font><font color="#000080"><b>&gt;= </b></font><font color="#FF0000">0 </font><b>then </b><font color="#000080">SPBRG <b>= </b></font><font color="#FF0000">usart_div </font><b>else </b><font color="#000080">SPBRG <b>= </b></font><font color="#FF0000">0 </font><b>end if
      </b><font color="#000080">baudrate_high <b>= </b></font><font color="#FF0000">true

    </font><font color="#808080"><i>-- try the low-speed mode
    </i></font><b>else
      const </b><font color="#FF0000">usart_div_low </font><font color="#000080"><b>= ((((</b></font><font color="#FF0000">10 </font><font color="#000080"><b>* </b>target_clock<b>) / ( </b></font><font color="#FF0000">64 </font><font color="#000080"><b>* </b></font><font color="#FF0000">baudrate </font><font color="#000080"><b>)) + </b></font><font color="#FF0000">5 </font><font color="#000080"><b>) / </b></font><font color="#FF0000">10</font><font color="#000080"><b>) - </b></font><font color="#FF0000">1
      </font><font color="#808080"><i>-- here divider will never be 0

      -- but special case to consider,
      -- if baudrate is just a little too low
      </i></font><b>if </b><font color="#000080"><b>(</b></font><font color="#FF0000">usart_div_low </font><font color="#000080"><b>&gt; </b></font><font color="#FF0000">255</font><font color="#000080"><b>) &amp;
         (</b></font><font color="#FF0000">100 </font><font color="#000080"><b>* ((</b>target_clock <b>/ (</b></font><font color="#FF0000">64 </font><font color="#000080"><b>* </b></font><font color="#FF0000">256 </font><font color="#000080"><b>)) - </b></font><font color="#FF0000">baudrate</font><font color="#000080"><b>)) / </b></font><font color="#FF0000">baudrate </font><font color="#000080"><b>&lt; </b></font><font color="#FF0000">max_deviation
      </font><b>then
        </b><font color="#000080">SPBRG <b>= </b></font><font color="#FF0000">255
        </font><font color="#000080">baudrate_high <b>= </b></font><font color="#FF0000">false

      </font><font color="#808080"><i>-- now calculate divider and set high-speed / low-speed bit
      </i></font><b>elsif </b><font color="#FF0000">usart_div_low </font><font color="#000080"><b>&lt;= </b></font><font color="#FF0000">255 </font><b>then
        if </b><font color="#FF0000">usart_div_low </font><font color="#000080"><b>&gt;= </b></font><font color="#FF0000">0 </font><b>then </b><font color="#000080">SPBRG <b>= </b></font><font color="#FF0000">usart_div_low </font><b>else </b><font color="#000080">SPBRG <b>= </b></font><font color="#FF0000">0 </font><b>end if
        </b><font color="#000080">baudrate_high <b>= </b></font><font color="#FF0000">false

      </font><b>else
        </b><font color="#800080"><i>pragma </i></font><b>error </b><font color="#808080"><i>-- asynchronous baudrate is too low
      </i></font><b>end if
    end if

    </b><font color="#808080"><i>-- now set baudrate high-low bit in TXSTA
    </i></font><b>if </b><font color="#000080">baudrate_high </font><b>then
      </b><font color="#000080">TXSTA <b>= </b>TXSTA <b>| </b></font><font color="#FF0000">_b_BRGH         </font><font color="#808080"><i>-- set baudrate-high flag
    </i></font><b>else
      </b><font color="#000080">TXSTA <b>= </b>TXSTA <b>&amp; ! ( </b></font><font color="#FF0000">_b_BRGH </font><font color="#000080"><b>)   </b></font><font color="#808080"><i>-- clear baudarte-high flag
    </i></font><b>end if


</b><font color="#808080"><i>;    assembler
;      bank 0
;      local L1,L2
;      page L2

;      btfss  baudrate_high ;skip if high baudrate
;      goto   L1                 ;
;      bsf    STATUS,RP0         ;select bank 1
;      bsf    _TXSTA,BRGH        ;set baufrate = high
;      goto   L2                 ;
;    L1:                         ;
;      bsf    STATUS,RP0         ;select bank 1
;      bcf    _TXSTA,BRGH        ;set baudrate = low
;    L2:                         ;
;      bcf    STATUS,RP0         ;back to bank 0
;    end assembler


  </i></font><b>else  </b><font color="#808080"><i>-- synchronous mode
    </i></font><b>const </b><font color="#FF0000">usart_div_sync </font><font color="#000080"><b>= ( </b>target_clock <b>/ ( </b></font><font color="#FF0000">4 </font><font color="#000080"><b>* </b></font><font color="#FF0000">baudrate </font><font color="#000080"><b>)) - </b></font><font color="#FF0000">1

    </font><font color="#808080"><i>-- special case if divider is 0 or negative
    -- test if baudrate is a little bit too high
    </i></font><b>if </b><font color="#FF0000">usart_div_sync </font><font color="#000080"><b>&lt;= </b></font><font color="#FF0000">0 </font><b>then
      if </b><font color="#000080"><b>(</b></font><font color="#FF0000">100 </font><font color="#000080"><b>* (</b></font><font color="#FF0000">baudrate </font><font color="#000080"><b>- (</b>target_clock <b>/ </b></font><font color="#FF0000">4 </font><font color="#000080"><b>) )) / </b></font><font color="#FF0000">baudrate </font><font color="#000080"><b>&gt;= </b></font><font color="#FF0000">max_deviation
      </font><b>then
        </b><font color="#800080"><i>pragma </i></font><b>error  </b><font color="#808080"><i>-- synchronous baudrate is too high
      </i></font><b>end if
    end if

    </b><font color="#808080"><i>-- special case to consider,
    -- if baudrate is just a little too high
    </i></font><b>if </b><font color="#000080"><b>(</b></font><font color="#FF0000">usart_div_sync </font><font color="#000080"><b>&gt; </b></font><font color="#FF0000">255</font><font color="#000080"><b>) &amp;
       (</b></font><font color="#FF0000">100 </font><font color="#000080"><b>* ((</b>target_clock <b>/ (</b></font><font color="#FF0000">4 </font><font color="#000080"><b>* </b></font><font color="#FF0000">256</font><font color="#000080"><b>)  ) - </b></font><font color="#FF0000">baudrate</font><font color="#000080"><b>)) / </b></font><font color="#FF0000">baudrate </font><font color="#000080"><b>&lt; </b></font><font color="#FF0000">max_deviation
    </font><b>then
      </b><font color="#000080">SPBRG <b>= </b></font><font color="#FF0000">255
    </font><b>elsif </b><font color="#FF0000">usart_div_sync </font><font color="#000080"><b>&lt;= </b></font><font color="#FF0000">255 </font><b>then
      if </b><font color="#000080">SPBRG <b>&gt;= </b></font><font color="#FF0000">0 </font><b>then </b><font color="#000080">SPBRG <b>= </b></font><font color="#FF0000">usart_div_sync </font><b>else </b><font color="#000080">SPBRG <b>= </b></font><font color="#FF0000">0 </font><b>end if
    else
      </b><font color="#800080"><i>pragma </i></font><b>error </b><font color="#808080"><i>-- synchronous baudrate is too low
    </i></font><b>end if
  end if
end procedure
</b><font color="#808080"><i>-- --------------------------------------------------------------------


-- --------------------------------------------------------------------
-- Initializes the SPI port, calculates baudrate registers.
-- Normally this routine should not be called by the user program,
-- it's called once at the end of this unit.
-- Only after &quot;asynch_disable_hw&quot; it's necessary to call this routine,
-- to enable the SPI hardware again.
-- --------------------------------------------------------------------
</i></font><b>procedure </b><font color="#000080">SPI_init </font><b>is
  </b><font color="#808080"><i>-- disable all USART interrupts
  </i></font><font color="#000080">_PIE1 <b>= </b>_PIE1 <b>&amp; (! </b></font><font color="#FF0000">_b_RCIE</font><font color="#000080"><b>)
  </b>_PIE1 <b>= </b>_PIE1 <b>&amp; (! </b></font><font color="#FF0000">_b_TXIE</font><font color="#000080"><b>)
</b></font><font color="#808080"><i>;intcon = 0

  -- Load baudrate generator
  </i></font><font color="#000080">_calculate_and_set_baudrate

  </font><font color="#808080"><i>-- TXSTA = Csrc - TX9 - TXEN - SYNC -- x - BRGH - TRMT - TX9D
  -- Csrc = 1 = master mode
  -- TX9  = 0 = disable 9 bit transmission
  -- TXEN = 1 = enable transmission
  -- SYNC = 1 = enable synchronous mode
  --
  -- x    = 0
  -- BRGH = 1 = high speed baudrate (in synchronous mode don't care)
  -- TRMT = 0 = true if TSR register empty (data is send)
  -- TX9D = 0 = 9-bit to be send
  </i></font><font color="#000080">TXSTA <b>= </b></font><font color="#FF0000">0b_1011_0100

  </font><font color="#808080"><i>-- RCSTA = SPEN - RX9 - SREN - CREN -- ADEN - FERR - OERR - RX9D
  -- SPEN = 1 = enable serial port
  -- RX9  = 0 = disable 9 bit receiving
  -- SREN = 0 = disable single byte reception
  -- CREN = 0 = disable multi byte reception (CREN=1 overrules SREN)
  --            also used to clear OERR
  --
  -- ADEN = 0 = address detect
  -- FERR = 0 = framing error
  -- OERR = 0 = overrun error (received bytes are not removed by reading RCREG)
  -- RX9D = 0 = 9-bit received
  -- Enable serial port : SPEN=1
  </i></font><font color="#000080">RCSTA <b>= </b></font><font color="#FF0000">0b_1000_0000

</font><b>end procedure
</b><font color="#808080"><i>-- --------------------------------------------------------------------


-- --------------------------------------------------------------------
-- Initializes the RS232 port, calculates baudrate registers.
-- Normally this routine should not be called by the user program,
-- it's called just once at the end of this unit
-- Only after &quot;asynch_disable_hw&quot; it's necessary to call this routine,
-- to enable the RS232 hardware again.
-- --------------------------------------------------------------------
</i></font><b>procedure </b><font color="#000080">asynch_init_hw </font><b>is
  </b><font color="#808080"><i>-- disable all USART interrupts
  </i></font><font color="#000080">_PIE1 <b>= </b>_PIE1 <b>&amp; (! </b></font><font color="#FF0000">_b_RCIE</font><font color="#000080"><b>)
  </b>_PIE1 <b>= </b>_PIE1 <b>&amp; (! </b></font><font color="#FF0000">_b_TXIE</font><font color="#000080"><b>)
</b></font><font color="#808080"><i>;intcon = 0

  -- Enable transmitter : TXEN=1
  </i></font><font color="#000080">TXSTA <b>= </b></font><font color="#FF0000">0x20

  </font><font color="#808080"><i>-- Load baudrate generator, must be done after TXSTA is loaded
  ;_TXSTA_BRGH = _calculate_SPBRG
  </i></font><font color="#000080">_calculate_and_set_baudrate

  </font><font color="#808080"><i>-- Enable serial port : SPEN=1
  </i></font><font color="#000080">RCSTA <b>= </b></font><font color="#FF0000">0x80

  </font><font color="#808080"><i>-- enable Receiver CREN = 1
  </i></font><font color="#000080">RCSTA <b>= </b>RCSTA <b>| </b></font><font color="#FF0000">0x10

  </font><font color="#808080"><i>-- Set RB2 as output
  -- MUST BE CHANGED THROUGH SHADOW
--  TRISB = 0x00

--  _portb = 0

</i></font><b>end procedure
</b><font color="#808080"><i>-- --------------------------------------------------------------------


-- --------------------------------------------------------------------
-- Disables USART (wether used as RS232 or SPI),
-- so ports can be used (temporary) for other purposes.
-- USART can be enabled again by calling   asynch_init_hw  or  SPI_init_hw
-- --------------------------------------------------------------------
</i></font><b>procedure </b><font color="#000080">asynch_disable_hw </font><b>is
  </b><font color="#808080"><i>-- Disable Serial port : SPEN=0
  </i></font><font color="#000080">SPEN <b>= </b></font><b>low
end procedure
</b><font color="#808080"><i>-- --------------------------------------------------------------------


-- --------------------------------------------------------------------
-- Asynchronuous RS232 send routine, using the TX pin
-- Sends byte X (8 bit with no parity) to the serial port
-- First checks (and waits if necessary) if transmit buffer is empty
--
-- remark: PIR1-register (containing _TXIF-flag) must be in bank0 !!
-- --------------------------------------------------------------------
</i></font><b>procedure </b><font color="#000080">asynch_send_hw <b>( </b></font><b>byte in </b><font color="#000080">x <b>) </b></font><b>is
  </b><font color="#808080"><i>-- wait until TXREG is empty
  </i></font><b>while </b><font color="#000080"><b>! </b>TXIF </font><b>loop end loop

  </b><font color="#808080"><i>-- then put new byte in TXREG (prepare for transmission)
  </i></font><font color="#000080">TXREG <b>= </b>x
</font><b>end procedure
</b><font color="#808080"><i>-- --------------------------------------------------------------------


-- --------------------------------------------------------------------
-- Returns truw if a character was received, otherwise returns false.
-- Overrun error flag is cleared.
-- --------------------------------------------------------------------
</i></font><b>function </b><font color="#000080">asynch_read_hw <b>( </b></font><b>byte out </b><font color="#000080">x <b>) </b></font><b>return bit is
var bit </b><font color="#000080">result

  </font><font color="#808080"><i>-- test if byte available, and if so,
  -- get byte and transport to outer world
  </i></font><b>if </b><font color="#000080">RCIF </font><b>then
    </b><font color="#000080">x <b>= </b>RCREG
    result <b>= </b></font><font color="#FF0000">true
  </font><b>else
    </b><font color="#000080">result <b>= </b></font><font color="#FF0000">false
  </font><b>end if


  </b><font color="#808080"><i>; if OverRun error, clear !!
  </i></font><b>if </b><font color="#000080"><b>( </b>RCSTA <b>&amp; </b></font><font color="#FF0000">0b_0000_0010 </font><font color="#000080"><b>) &gt; </b></font><font color="#FF0000">0 </font><b>then
    </b><font color="#000080">RCSTA <b>= </b>RCSTA <b>&amp; ( ! </b></font><font color="#FF0000">0x10</font><font color="#000080"><b>)
    </b>RCSTA <b>= </b>RCSTA <b>| (</b></font><font color="#FF0000">0x10</font><font color="#000080"><b>)
  </b></font><b>end if

  return </b><font color="#000080">result
</font><b>end function
</b><font color="#808080"><i>-- --------------------------------------------------------------------


-- --------------------------------------------------------------------
-- SPI send routine, using the TX pin
-- Sends byte X (8 bit with no parity) to the serial port
-- After sending the byte, this routine will wait till byte is really transmitted.
-- This is done in order to be able to use CS for multiple SPI-devices.
--
-- remark: PIR1-register (containing _TXIF-flag) must be in bank0 !!
-- --------------------------------------------------------------------
</i></font><b>procedure </b><font color="#000080">SPI_send_hw <b>( </b></font><b>byte in </b><font color="#000080">x <b>) </b></font><b>is
  </b><font color="#808080"><i>-- enable transmission
  </i></font><font color="#000080">TXSTA <b>= </b>TXSTA <b>| </b></font><font color="#FF0000">0b_0010_0000

  </font><font color="#000080">asynch_send_hw <b>(</b>x<b>)

  </b></font><font color="#808080"><i>-- wait till transmission ready (safe through empty of TSR register)
  </i></font><b>while  </b><font color="#000080"><b>(( </b>TXSTA <b>&amp; </b></font><font color="#FF0000">0b_0000_0010 </font><font color="#000080"><b>) == </b></font><font color="#FF0000">0 </font><font color="#000080"><b>)  </b></font><b>loop end loop

  </b><font color="#808080"><i>-- disable transmission
  </i></font><font color="#000080">TXSTA <b>= </b>TXSTA <b>&amp; (! </b></font><font color="#FF0000">0b_0010_0000</font><font color="#000080"><b>)
</b></font><b>end procedure
</b><font color="#808080"><i>-- --------------------------------------------------------------------


-- --------------------------------------------------------------------
-- reads a byte from the SPI-bus
-- After reception, all error flags are cleared
-- --------------------------------------------------------------------
</i></font><b>procedure </b><font color="#000080">SPI_read_hw <b>( </b></font><b>byte out </b><font color="#000080">x <b>) </b></font><b>is

  </b><font color="#808080"><i>-- enable receiving
  </i></font><font color="#000080">RCSTA <b>= </b>RCSTA <b>&amp; (! </b></font><font color="#FF0000">0x30 </font><font color="#000080"><b>)    </b></font><font color="#808080"><i>-- clear OERR, by clearing CREN and SREN
  </i></font><font color="#000080">RCSTA <b>= </b>RCSTA <b>| </b></font><font color="#FF0000">0x20         </font><font color="#808080"><i>-- enable single reception

  -- wait until byte received, RXREG is filled
  </i></font><b>while </b><font color="#000080"><b>! </b>RCIF </font><b>loop end loop

  </b><font color="#808080"><i>-- get byte and transport to outer world
  </i></font><font color="#000080">x <b>= </b>RCREG

  </font><font color="#808080"><i>-- clear all errors and disable reception
  </i></font><font color="#000080">RCSTA <b>= </b>RCSTA <b>&amp; (! </b></font><font color="#FF0000">0x30 </font><font color="#000080"><b>)    </b></font><font color="#808080"><i>-- clear OERR, by clearing CREN and SREN
</i></font><b>end procedure
</b><font color="#808080"><i>-- --------------------------------------------------------------------


-- --------------------------------------------------------------------
-- initialization, depending on the parameters set by the user,
-- the baudrate is calculated and all the relevant registers are set
-- --------------------------------------------------------------------
</i></font><b>if </b><font color="#FF0000">usart_asynch </font><b>then
  </b><font color="#000080">asynch_init_hw
</font><b>else
  </b><font color="#000080">spi_init
</font><b>end if
</b><font color="#808080"><i>-- --------------------------------------------------------------------

</i></font></font>
</code></pre>
</body>
</html>
