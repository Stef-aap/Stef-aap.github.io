<html>
<head>
<title>JALcc SourceCode exporting of rs232_sw_source.html</title>
</head>
<!-- Generated by SynEdit HTML exporter -->
<body text="#000000" bgcolor="#FFFFFF">
<pre>
<code><font  size=3 face="Courier New"><font color="#000080"><A href="rs232_sw.jal">download&nbsp;rs232_sw.jal</A>

</font><font color="#808080"><i>-- -----------------------------------------------------------------------------
-- &lt;title Software RS232 library
-- &lt;License
-- freeware, under the terms of the GNU GPL
--  Copyright (C) 2002 Stef Mientki
-- -----------------------------------------------------------------------------
-- &lt;Description
-- Library supports software RS232 send and receive procedure on any IO-pin.
-- Both the inverted and non-inverted routines are available, 
-- so it should fit any hardware.
-- Baudrate can be set between 110 and 230_400 (for 20 Mhz Xtal)
-- for lower Xtal frequencies the maximum baudrate will be equally lower.
-- Baudrates are optimized, so even the high baudrates shouldn't be a problem
-- (my standard = 115_200 Baud, which has never given me any problems).
--  Interrupts should be disabled during transmissions.
--  Transmission parameters are 8 databits, 2 stopbits, no parity, no handshake.
--
-- &lt;non-tag
-- Send a character
--   procedure asynch_send_sw (byte in x) is
--
-- Receive a character
--   procedure asynch_receive_sw (byte out x) is
--
-- Initialisation (are called automatically)
--   procedure asynch_sw_init_transmit is
--   procedure asynch_sw_init_receive is
--
-- &lt;Version: 2.0 future wishes
--   - timeout in receive routine
--   - receive routine as boolean function, true=new character, false=timeout
-- &lt;Version: 1.2     ,03-11-2002 ,Stef Mientki
--   - inverted version of receive and transmit added
-- &lt;Version: 1.1     ,28-02-2002 ,Stef Mientki
--   - naming of registers changed to SM-notation
-- &lt;Version: 1.0     ,03-01-2002 ,Stef Mientki
-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- &lt;Example software RS232
; -- define transmission settings
; const asynch_baudrate_sw = 115_200
; const asynch_invert_sw   = true
;
; -- define the software transmit/receive pin
; &lt;mac&gt; io_pin  asynch_sw_out = pin_b7
; &lt;mac&gt; io_pin  asynch_sw_in  = pin_b6
; include rs232_sw
;
; -- start initializations if functions are used
; asynch_sw_init_transmit
; asynch_sw_init_receive
;
; var byte xx
; forever loop
;   -- wait till character received, echo inverted
;   asynch_read_sw (xx)
;   asynch_send_sw ( ! xx)
;   ... do other things
; end loop
-- -----------------------------------------------------------------------------


-- &lt;code

-- -----------------------------------------------------------------------------
-- number of instructions per bit
-- -----------------------------------------------------------------------------
</i></font><b>const </b><font color="#FF0000">_Ninstr </font><font color="#000080"><b>= </b>target_clock <b>/ (</b></font><font color="#FF0000">4 </font><font color="#000080"><b>* </b></font><font color="#FF0000">asynch_baudrate_sw</font><font color="#000080"><b>)
</b></font><b>const </b><font color="#FF0000">_Ninstr2 </font><font color="#000080"><b>= </b></font><font color="#FF0000">5 </font><font color="#000080"><b>+ ( </b></font><font color="#FF0000">_Ninstr </font><font color="#000080"><b>/ </b></font><font color="#FF0000">2</font><font color="#000080"><b>)
</b></font><font color="#808080"><i>-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- Transmit parameters
-- -----------------------------------------------------------------------------
  </i></font><b>const </b><font color="#FF0000">OL_Tx  </font><font color="#000080"><b>= ( </b></font><font color="#FF0000">_Ninstr </font><font color="#000080"><b>/ ( </b></font><font color="#FF0000">3 </font><font color="#000080"><b>* </b></font><font color="#FF0000">255 </font><font color="#000080"><b>)) + </b></font><font color="#FF0000">1
  </font><b>const </b><font color="#FF0000">_IL_Tx  </font><font color="#000080"><b>= ( ( </b></font><font color="#FF0000">_Ninstr </font><font color="#000080"><b>- ( </b></font><font color="#FF0000">4 </font><font color="#000080"><b>* </b></font><font color="#FF0000">OL_Tx </font><font color="#000080"><b>) ) - </b></font><font color="#FF0000">16 </font><font color="#000080"><b>) / ( </b></font><font color="#FF0000">3 </font><font color="#000080"><b>* </b></font><font color="#FF0000">OL_Tx </font><font color="#000080"><b>)

  </b></font><font color="#808080"><i>-- because some corrections have to be made, declare InnerLoop counter as var
  </i></font><b>var byte </b><font color="#000080">IL_Tx <b>= </b></font><font color="#FF0000">_IL_Tx

  </font><font color="#808080"><i>-- for small values, the value is truncated in stead of rounded, so add 1
  </i></font><b>if </b><font color="#FF0000">_IL_Tx </font><font color="#000080"><b>&lt; </b></font><font color="#FF0000">10 </font><b>then
    </b><font color="#000080">IL_Tx <b>= </b></font><font color="#FF0000">_IL_Tx </font><font color="#000080"><b>+ </b></font><font color="#FF0000">1
  </font><b>end if
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------
-- For Xtal = 20_000_000, the following counter values are calculated (in Hex)
--  Baud      OLcnt    ILcnt     Ninstr
--  110       3C       FB
--  300       16       FA
--  600       0B       FA
--  1200      06       E5
--  2400      03       E4
--  4800      02       A9
--  9600      01       A6
--  14_400    01       6D
--  19_200    01       50
--  38_400    01       24
--  57_600    01       16
--  115_200   01       08        43
--  230_400   01       01        22    NOT TESTED
--
-- Test sequence used: all possibilities
-- -----------------------------------------------------------------------------



-- -----------------------------------------------------------------------------
-- receiving is optimized for 20 Mhz, 320_400 Baud
--   Number of instructions = (3 * OLval * Ilval) + (4 * OLval) + 15
-- 320kB  ==&gt;  OLval = ILval = 1
-- next optimization for 20 Mhz, 115_200 Baud  OLval = 1
--   OLval = 1   ==&gt;   ILval = 8
-- all other buadrates downto 1200 shouldnt be a problem now
-- because of &quot;IF-statement&quot; this constant must be declared as a var
</i></font><b>var byte </b><font color="#000080">ILval
</font><b>var byte </b><font color="#000080">OLval
</font><b>var byte </b><font color="#000080">ILval0

</font><b>if </b><font color="#FF0000">asynch_baudrate_sw </font><font color="#000080"><b>&lt; </b></font><font color="#FF0000">200_000 </font><b>then
  const </b><font color="#FF0000">_OLval  </font><font color="#000080"><b>= ( </b></font><font color="#FF0000">_Ninstr </font><font color="#000080"><b>/ ( </b></font><font color="#FF0000">3 </font><font color="#000080"><b>* </b></font><font color="#FF0000">255 </font><font color="#000080"><b>)) + </b></font><font color="#FF0000">1
  </font><b>const </b><font color="#FF0000">_ILval  </font><font color="#000080"><b>= ( ( </b></font><font color="#FF0000">_Ninstr </font><font color="#000080"><b>- ( </b></font><font color="#FF0000">4 </font><font color="#000080"><b>* </b></font><font color="#FF0000">_OLval </font><font color="#000080"><b>) ) - </b></font><font color="#FF0000">15 </font><font color="#000080"><b>) / ( </b></font><font color="#FF0000">3 </font><font color="#000080"><b>* </b></font><font color="#FF0000">_OLval </font><font color="#000080"><b>)
  </b></font><b>const </b><font color="#FF0000">_ILval0 </font><font color="#000080"><b>= ( ( </b></font><font color="#FF0000">_Ninstr2 </font><font color="#000080"><b>- ( </b></font><font color="#FF0000">4 </font><font color="#000080"><b>* </b></font><font color="#FF0000">_OLval </font><font color="#000080"><b>) ) - </b></font><font color="#FF0000">5 </font><font color="#000080"><b>) / ( </b></font><font color="#FF0000">3 </font><font color="#000080"><b>* </b></font><font color="#FF0000">_OLval </font><font color="#000080"><b>)


  </b>ILval  <b>= </b></font><font color="#FF0000">_ILval
  </font><font color="#000080">OLval  <b>= </b></font><font color="#FF0000">_OLval
  </font><font color="#808080"><i>;due to rounding the next value can slightly below 1
  </i></font><b>if </b><font color="#FF0000">_ILval0 </font><font color="#000080"><b>&gt; </b></font><font color="#FF0000">0 </font><b>then </b><font color="#000080">ILval0 <b>= </b></font><font color="#FF0000">_ILval0 </font><b>else </b><font color="#000080">ILval0 <b>= </b></font><font color="#FF0000">1 </font><b>end if
  </b><font color="#000080">ILval0 <b>= </b></font><font color="#FF0000">_ILval0

  </font><font color="#808080"><i>-- test if baudrate valid for the chosen Xtal frequency
  </i></font><b>if </b><font color="#FF0000">_OLval </font><font color="#000080"><b>&gt; </b></font><font color="#FF0000">255 </font><b>then
    </b><font color="#800080"><i>pragma </i></font><b>error  </b><font color="#808080"><i>-- baudrate too low for this Xtal
  </i></font><b>end if
  if </b><font color="#FF0000">_OLval </font><font color="#000080"><b>== </b></font><font color="#FF0000">0 </font><b>then
    </b><font color="#800080"><i>pragma </i></font><b>error  </b><font color="#808080"><i>-- baudrate too high for this Xtal
  </i></font><b>end if

else
  const </b><font color="#FF0000">_ILval </font><font color="#000080"><b>= </b></font><font color="#FF0000">1
  </font><b>const </b><font color="#FF0000">_OLval </font><font color="#000080"><b>= ((</b>target_clock <b>/ (</b></font><font color="#FF0000">4 </font><font color="#000080"><b>* </b></font><font color="#FF0000">asynch_baudrate_sw</font><font color="#000080"><b>)) - </b></font><font color="#FF0000">15 </font><font color="#000080"><b>) / (</b></font><font color="#FF0000">4 </font><font color="#000080"><b>+ </b></font><font color="#FF0000">3 </font><font color="#000080"><b>* </b></font><font color="#FF0000">_ILval</font><font color="#000080"><b>)
  </b>ILval <b>= </b></font><font color="#FF0000">_ILval
  </font><font color="#000080">OLval <b>= </b></font><font color="#FF0000">_OLval

</font><b>end if
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------
-- For Xtal = 20_000_000, the following counter values are calculated (in Hex)
--  Baud      OLcnt    ILcnt     ILcnt0      Ninstr
--  110       3C       FB        7C
--  300       16       FA        7C
--  600       0B       FA        7C
--  1200      06       E5        72
--  2400      03       E4        72
--  4800      02       A9        55
--  9600      01       A7        55
--  14_400    01       6D        38
--  19_200    01       50        2A
--  38_400    01       25        14
--  57_600    01       16        0D
--  115_200   01       08        05          43
--  230_400   ?        ?         ?           22    NOT TESTED
--
-- Test sequence used (Hex)
--    01  02  04  08  10  20  40  80  00 FF  AA  55
-- -----------------------------------------------------------------------------



-- -----------------------------------------------------------------------------
-- Sends (by software) the byte &quot;X&quot; to the RS232 port
-- Baudrate can be set between 110 and 230_400 for a 20 MHz Xtal
-- If required baudrate is too low or too high a pragma error is generated.
-- On entering this routine, the interrupts will be disabled and left disabled.
--
-- I couldn't think of an elegant way to realize both inverted and non-inverting,
-- so I just copied the code inside and used a compiler if-directive
-- The 2 stopbits can easily adapted by chnaging BITCNT
-- 230_400 not yet tested, theoretical there's 1 instruction to much,
-- but I can't figure out how to save 1 (in a simple way).
-- Output to the port is nicely done through the shadow register.
--
-- The first bytes transmitted are rubish, but that can well be caused by the very
-- simple hardware used.
-- -----------------------------------------------------------------------------
</i></font><b>procedure </b><font color="#000080">asynch_send_sw <b>(</b></font><b>byte in </b><font color="#000080">x<b>) </b></font><b>is

</b><font color="#808080"><i>-- local variables
</i></font><b>var byte </b><font color="#000080">data      </font><font color="#808080"><i>;holds the actual data to be sent
</i></font><b>var byte </b><font color="#000080">bitcnt    </font><font color="#808080"><i>;holds the actual number of bits to be sent
</i></font><b>var byte </b><font color="#000080">OLcnt     </font><font color="#808080"><i>;loop counter
</i></font><b>var byte </b><font color="#000080">ILcnt     </font><font color="#808080"><i>;inner loop counter

-- define some registers and bits with shorter names
</i></font><b>const </b><font color="#FF0000">pp </font><font color="#000080"><b>= </b></font><font color="#FF0000">asynch_sw_out_nr
</font><b>var volatile byte </b><font color="#000080">port </font><b>is </b><font color="#000080">asynch_sw_out_port
</font><b>var volatile byte </b><font color="#000080">pa   </font><b>is </b><font color="#000080">asynch_sw_out_buffer


  </font><font color="#808080"><i>-- stop interrupts and be sure they are stopped
  </i></font><b>while </b><font color="#000080">gie </font><b>loop
    </b><font color="#000080">gie <b>= </b></font><font color="#FF0000">false
  </font><b>end loop

  </b><font color="#000080">data <b>= </b>x
  bitcnt <b>= </b></font><font color="#FF0000">11    </font><font color="#808080"><i>; 11 bits = startbit + 8 databits + 2 stopbits


  </i></font><b>if </b><font color="#FF0000">asynch_invert_sw </font><b>then
    </b><font color="#800080"><i>assembler
    bank </i></font><font color="#FF0000">0
    </font><font color="#800080"><i>local </i></font><font color="#000080">_bit_time<b>, </b>_bit_time2<b>, </b>_bit_time3<b>, </b>_send_byte<b>, </b>_next_bit
    </font><font color="#800080"><i>page </i></font><font color="#000080">_next_bit

    goto   _send_byte    </font><font color="#808080"><i>;jump over delay routine, I don't know any other way

    ;-----------------------------------------------------------------------------
    </i></font><font color="#000080">_bit_time<b>:           </b></font><font color="#808080"><i>;(2) (length of call instruction)
      </i></font><font color="#800080"><i>movlw   </i></font><font color="#FF0000">OL_Tx      </font><font color="#808080"><i>;(1) Accumulator = Outer Loop Counter
      </i></font><font color="#000080">movwf   OLcnt      </font><font color="#808080"><i>;(1) OUTLOOP = Accumulator

    </i></font><font color="#000080">_bit_time2<b>:          </b></font><font color="#808080"><i>;=============  start of double loop
      </i></font><font color="#000080">movfw   IL_Tx      </font><font color="#808080"><i>;(1) Accumulator = Inner Loop Counter
      </i></font><font color="#000080">movwf   ILcnt      </font><font color="#808080"><i>;(1) INLOOP = Accumulator
    </i></font><font color="#000080">_bit_time3<b>:          </b></font><font color="#808080"><i>;
      </i></font><font color="#000080">decfsz  ILcnt<b>,</b>f    </font><font color="#808080"><i>;(1)
      </i></font><font color="#000080">goto    _bit_time3 </font><font color="#808080"><i>;(2)
      </i></font><font color="#000080">decfsz  OLcnt<b>,</b>f    </font><font color="#808080"><i>;(1)
      </i></font><font color="#000080">goto    _bit_time2 </font><font color="#808080"><i>;(2)
                         ;============= end of double loop
                         ; OLval * { ( ILval * 3 ) -1 +5 } -1
                         ; = 3*OLval*ILval + 4*OLval -1
                         ; OLval=ILval=1  ==&gt; 6
    </i></font><b>return               </b><font color="#808080"><i>;(2)
                         ;total instructions (including call)
                         ;   3*OLval*ILval + 4*OLval +5
    ;-----------------------------------------------------------------------------


    </i></font><font color="#000080">_send_byte<b>:
       </b>bcf    status<b>,</b>C   </font><font color="#808080"><i>;clear Carry (start bit)
    </i></font><font color="#000080">_next_bit<b>:

      </b></font><font color="#808080"><i>;using the shadow register of the port:
      ;  - assures no other pins of the port are affected
      ;  - delay is always the same
      ;----- the length of this block is independant of the bit value
       </i></font><font color="#000080">btfsc  status<b>,</b>C   </font><font color="#808080"><i>;(1/2) test Carry, skip if clear
       </i></font><font color="#000080">bsf    pa<b>,</b></font><font color="#FF0000">pp      </font><font color="#808080"><i>;(1/0) data bit = 1 ==&gt; out = high
       </i></font><font color="#000080">btfss  status<b>,</b>C   </font><font color="#808080"><i>;(2/1) test Carry, skip if set
       </i></font><font color="#000080">bcf    pa<b>,</b></font><font color="#FF0000">pp      </font><font color="#808080"><i>;(0/1) data bit = 0 ==&gt; out = low

       </i></font><font color="#000080">movfw  pa         </font><font color="#808080"><i>;(1) output buffer to accumulator
       </i></font><font color="#000080">movwf  port       </font><font color="#808080"><i>;(1) send output buffer to port
      ;------this block is always (6) instructions

       </i></font><font color="#000080">call   _bit_time  </font><font color="#808080"><i>;( 3*OLval*ILval + 4*OLval + 5 )
       </i></font><font color="#000080">bsf    status<b>,</b>C   </font><font color="#808080"><i>;(1) set Carry (will be shifted in data byte)
       </i></font><font color="#000080">rrf    data<b>,</b>f     </font><font color="#808080"><i>;(1) shift data byte, so next bit goes to Carry
       </i></font><font color="#000080">decfsz bitcnt<b>,</b>f   </font><font color="#808080"><i>;(1) decrement bit count, exit routine if zero
       </i></font><font color="#000080">goto   _next_bit  </font><font color="#808080"><i>;(2) continue routine
                         ;total
                         ;   ( 3*OLval*ILval + 4*OLval + 16 )
    </i></font><b>end </b><font color="#800080"><i>assembler

  </i></font><b>else
    </b><font color="#800080"><i>assembler
    bank </i></font><font color="#FF0000">0
    </font><font color="#800080"><i>local </i></font><font color="#000080">_bit_time<b>, </b>_bit_time2<b>, </b>_bit_time3<b>, </b>_send_byte<b>, </b>_next_bit
    </font><font color="#800080"><i>page </i></font><font color="#000080">_next_bit

    goto   _send_byte    </font><font color="#808080"><i>;jump over delay routine, I don't know any other way

    ;-----------------------------------------------------------------------------
    </i></font><font color="#000080">_bit_time<b>:           </b></font><font color="#808080"><i>;(2) (length of call instruction)
      </i></font><font color="#800080"><i>movlw   </i></font><font color="#FF0000">OL_Tx      </font><font color="#808080"><i>;(1) Accumulator = Outer Loop Counter
      </i></font><font color="#000080">movwf   OLcnt      </font><font color="#808080"><i>;(1) OUTLOOP = Accumulator

    </i></font><font color="#000080">_bit_time2<b>:          </b></font><font color="#808080"><i>;=============  start of double loop
      </i></font><font color="#000080">movfw   IL_Tx      </font><font color="#808080"><i>;(1) Accumulator = Inner Loop Counter
      </i></font><font color="#000080">movwf   ILcnt      </font><font color="#808080"><i>;(1) INLOOP = Accumulator
    </i></font><font color="#000080">_bit_time3<b>:          </b></font><font color="#808080"><i>;
      </i></font><font color="#000080">decfsz  ILcnt<b>,</b>f    </font><font color="#808080"><i>;(1)
      </i></font><font color="#000080">goto    _bit_time3 </font><font color="#808080"><i>;(2)
      </i></font><font color="#000080">decfsz  OLcnt<b>,</b>f    </font><font color="#808080"><i>;(1)
      </i></font><font color="#000080">goto    _bit_time2 </font><font color="#808080"><i>;(2)
                         ;============= end of double loop
                         ; OLval * { ( ILval * 3 ) -1 +5 } -1
                         ; = 3*OLval*ILval + 4*OLval -1
                         ; OLval=ILval=1  ==&gt; 6
    </i></font><b>return               </b><font color="#808080"><i>;(2)
                         ;total instructions (including call)
                         ;   3*OLval*ILval + 4*OLval +5
    ;-----------------------------------------------------------------------------


    </i></font><font color="#000080">_send_byte<b>:
       </b>bcf    status<b>,</b>C   </font><font color="#808080"><i>;clear Carry (start bit)
    </i></font><font color="#000080">_next_bit<b>:

      </b></font><font color="#808080"><i>;using the shadow register of the port:
      ;  - assures no other pins of the port are affected
      ;  - delay is always the same
      ;----- the length of this block is independant of the bit value
       </i></font><font color="#000080">btfsc  status<b>,</b>C   </font><font color="#808080"><i>;(1/2) test Carry, skip if clear
       </i></font><font color="#000080">bcf    pa<b>,</b></font><font color="#FF0000">pp      </font><font color="#808080"><i>;(1/0) data bit = 1 ==&gt; out = high
       </i></font><font color="#000080">btfss  status<b>,</b>C   </font><font color="#808080"><i>;(2/1) test Carry, skip if set
       </i></font><font color="#000080">bsf    pa<b>,</b></font><font color="#FF0000">pp      </font><font color="#808080"><i>;(0/1) data bit = 0 ==&gt; out = low

       </i></font><font color="#000080">movfw  pa         </font><font color="#808080"><i>;(1) output buffer to accumulator
       </i></font><font color="#000080">movwf  port       </font><font color="#808080"><i>;(1) send output buffer to port
      ;------this block is always (6) instructions

       </i></font><font color="#000080">call   _bit_time  </font><font color="#808080"><i>;( 3*OLval*ILval + 4*OLval + 5 )
       </i></font><font color="#000080">bsf    status<b>,</b>C   </font><font color="#808080"><i>;(1) set Carry (will be shifted in data byte)
       </i></font><font color="#000080">rrf    data<b>,</b>f     </font><font color="#808080"><i>;(1) shift data byte, so next bit goes to Carry
       </i></font><font color="#000080">decfsz bitcnt<b>,</b>f   </font><font color="#808080"><i>;(1) decrement bit count, exit routine if zero
       </i></font><font color="#000080">goto   _next_bit  </font><font color="#808080"><i>;(2) continue routine
                         ;total
                         ;   ( 3*OLval*ILval + 4*OLval + 16 )
    </i></font><b>end </b><font color="#800080"><i>assembler
  </i></font><b>end if
end procedure
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------



-- -----------------------------------------------------------------------------
-- waits untill a character is received.
-- Interrupts should be disabled prior to entering this routine.
-- Also here the code is doubled (inverting and non-inverting)
-- and selection is done by a compiler-directive.
-- -----------------------------------------------------------------------------
</i></font><b>procedure </b><font color="#000080">asynch_receive_sw <b>( </b></font><b>byte out </b><font color="#000080">x <b>) </b></font><b>is

</b><font color="#808080"><i>-- local variables
</i></font><b>var byte </b><font color="#000080">bitcnt    </font><font color="#808080"><i>;holds the actual number of bits to be sent
</i></font><b>var byte </b><font color="#000080">outloop   </font><font color="#808080"><i>;loop counter
</i></font><b>var byte </b><font color="#000080">inloop    </font><font color="#808080"><i>;inner loop counter
</i></font><b>var byte </b><font color="#000080">samp      </font><font color="#808080"><i>;sampled bit

</i></font><b>var volatile byte </b><font color="#000080">pa </font><b>is </b><font color="#000080">asynch_sw_in_port
</font><b>const </b><font color="#FF0000">pp </font><font color="#000080"><b>= </b></font><font color="#FF0000">asynch_sw_in_nr

  </font><font color="#000080">bitcnt <b>= </b></font><font color="#FF0000">8

  </font><b>if </b><font color="#FF0000">asynch_invert_sw </font><b>then
    </b><font color="#800080"><i>assembler
    bank </i></font><font color="#FF0000">0
    </font><font color="#800080"><i>local </i></font><font color="#000080">wait_idle
    </font><font color="#800080"><i>local </i></font><font color="#000080">wait_start<b>, </b>wait_start2<b>, </b>wait_start3
    </font><font color="#800080"><i>local </i></font><font color="#000080">next_bit<b>, </b>next_bit2<b>, </b>next_bit3
    </font><font color="#800080"><i>page </i></font><font color="#000080">next_bit

    wait_idle<b>:
      </b>btfss  pa<b>,</b></font><font color="#FF0000">pp      </font><font color="#808080"><i>;wait till receiver line is inactive (high)
      </i></font><font color="#000080">goto   wait_idle  </font><font color="#808080"><i>;

    </i></font><font color="#000080">wait_start<b>:
      </b>btfsc  pa<b>,</b></font><font color="#FF0000">pp      </font><font color="#808080"><i>;(2) wait for startbit
      </i></font><font color="#000080">goto   wait_start </font><font color="#808080"><i>;

      ; especially at higher Baud rates a good start must be made here
      ; 230 kB, half bittime = 11 instructions (2 already done)
      ; now 12 instructions,
      ; if too long, the next instructions can be moved above wait_start
      </i></font><font color="#000080">movfw   OLval      </font><font color="#808080"><i>;(1) Accumulator = Outer Loop Counter
      </i></font><font color="#000080">movwf   outloop    </font><font color="#808080"><i>;(1) OUTLOOP = Accumulator


    </i></font><font color="#000080">wait_start2<b>:         </b></font><font color="#808080"><i>;=============  start of double loop
      </i></font><font color="#000080">movfw   ILval0     </font><font color="#808080"><i>;(1) Accumulator = Inner Loop Counter
      </i></font><font color="#000080">movwf   inloop     </font><font color="#808080"><i>;(1) INLOOP = Accumulator
    </i></font><font color="#000080">wait_start3<b>:         </b></font><font color="#808080"><i>;
      </i></font><font color="#000080">decfsz  inloop<b>,</b>f   </font><font color="#808080"><i>;(1)
      </i></font><font color="#000080">goto    wait_start3</font><font color="#808080"><i>;(2)

      </i></font><font color="#000080">decfsz  outloop<b>,</b>f  </font><font color="#808080"><i>;(1)
      </i></font><font color="#000080">goto    wait_start2</font><font color="#808080"><i>;(2)
                         ;============= end of double loop
                         ; OLval * { ( ILval * 3 ) -1 +5 } -1
                         ; = 3*OLval*ILval + 4*OLval -1
                         ; OLval=ILval=1  ==&gt; 6

    ;test if still startbit,
      </i></font><font color="#000080">btfsc  pa<b>,</b></font><font color="#FF0000">pp      </font><font color="#808080"><i>;(2)
      </i></font><font color="#000080">goto   wait_idle  </font><font color="#808080"><i>; if not a start bit anymore, error, seek further

    ;-----------------------------------------------------------------------
    </i></font><font color="#000080">next_bit<b>:
      </b>movfw   OLval      </font><font color="#808080"><i>;(1) Accumulator = Outer Loop Counter
      </i></font><font color="#000080">movwf   outloop    </font><font color="#808080"><i>;(1) OUTLOOP = Accumulator

      ;to optimize for 230 kBaud, we need 22 instructions,
      ;so we still miss 3 instructions
      ;now it will be clear: calling a delay routine isn't possible (4 instructions)
      </i></font><font color="#000080">nop                </font><font color="#808080"><i>;(1)
      </i></font><font color="#000080">goto    next_bit2  </font><font color="#808080"><i>;(2)

    </i></font><font color="#000080">next_bit2<b>:           </b></font><font color="#808080"><i>;=============  start of double loop
      </i></font><font color="#000080">movfw   ILval      </font><font color="#808080"><i>;(1) Accumulator = Inner Loop Counter
      </i></font><font color="#000080">movwf   inloop     </font><font color="#808080"><i>;(1) INLOOP = Accumulator
    </i></font><font color="#000080">next_bit3<b>:           </b></font><font color="#808080"><i>;
      </i></font><font color="#000080">decfsz  inloop<b>,</b>f   </font><font color="#808080"><i>;(1)
      </i></font><font color="#000080">goto    next_bit3  </font><font color="#808080"><i>;(2)

      </i></font><font color="#000080">decfsz  outloop<b>,</b>f  </font><font color="#808080"><i>;(1)
      </i></font><font color="#000080">goto    next_bit2  </font><font color="#808080"><i>;(2)
                         ;============= end of double loop
                         ; OLval * { ( ILval * 3 ) -1 +5 } -1
                         ; = 3*OLval*ILval + 4*OLval -1
                         ; OLval=ILval=1  ==&gt; 6



      ;----- the length of this block is independant of the sampled character
      </i></font><font color="#000080">movfw  pa          </font><font color="#808080"><i>;(1) always sample once and store in buffer SAMP
      </i></font><font color="#000080">movwf  samp        </font><font color="#808080"><i>;(1)
      </i></font><font color="#000080">btfsc  samp<b>,</b></font><font color="#FF0000">pp     </font><font color="#808080"><i>;(1/2) DATA IS INVERTED !!
      </i></font><font color="#000080">bsf    status<b>,</b>C    </font><font color="#808080"><i>;(1/0) clear Carry (will be shifted in data byte)
      </i></font><font color="#000080">btfss  samp<b>,</b></font><font color="#FF0000">pp     </font><font color="#808080"><i>;(2/1)
      </i></font><font color="#000080">bcf    status<b>,</b>C    </font><font color="#808080"><i>;(0/1) set Carry (will be shifted in data byte)
      ;------this block is always (6) instructions

      </i></font><font color="#000080">rrf    x<b>,</b>f         </font><font color="#808080"><i>;(1) shift Carry in result byte


      </i></font><font color="#000080">decfsz bitcnt<b>,</b>f    </font><font color="#808080"><i>;(1) decrement bit count, exit routine if zero
      </i></font><font color="#000080">goto   next_bit    </font><font color="#808080"><i>;(2) continue routine
                         ;(16) without the double loop
                         ; = 3*OLval*ILval + 4*OLval +15
                         ; OLval=ILval=1  ==&gt; 22
    </i></font><b>end </b><font color="#800080"><i>assembler

  </i></font><b>else  </b><font color="#808080"><i>;NOT inverted
    </i></font><font color="#800080"><i>assembler
    bank </i></font><font color="#FF0000">0
    </font><font color="#800080"><i>local </i></font><font color="#000080">wait_idle
    </font><font color="#800080"><i>local </i></font><font color="#000080">wait_start<b>, </b>wait_start2<b>, </b>wait_start3
    </font><font color="#800080"><i>local </i></font><font color="#000080">next_bit<b>, </b>next_bit2<b>, </b>next_bit3
    </font><font color="#800080"><i>page </i></font><font color="#000080">next_bit

    wait_idle<b>:
      </b>btfsc  pa<b>,</b></font><font color="#FF0000">pp      </font><font color="#808080"><i>;wait till receiver line is inactive (low)
      </i></font><font color="#000080">goto   wait_idle  </font><font color="#808080"><i>;

    </i></font><font color="#000080">wait_start<b>:
      </b>btfss  pa<b>,</b></font><font color="#FF0000">pp      </font><font color="#808080"><i>;(2) wait for startbit
      </i></font><font color="#000080">goto   wait_start </font><font color="#808080"><i>;

      ; especially at higher Baud rates a good start must be made here
      ; 230 kB, half bittime = 11 instructions (2 already done)
      ; now 12 instructions,
      ; if too long, the next instructions can be moved above wait_start
      </i></font><font color="#000080">movfw   OLval      </font><font color="#808080"><i>;(1) Accumulator = Outer Loop Counter
      </i></font><font color="#000080">movwf   outloop    </font><font color="#808080"><i>;(1) OUTLOOP = Accumulator


    </i></font><font color="#000080">wait_start2<b>:         </b></font><font color="#808080"><i>;=============  start of double loop
      </i></font><font color="#000080">movfw   ILval0     </font><font color="#808080"><i>;(1) Accumulator = Inner Loop Counter
      </i></font><font color="#000080">movwf   inloop     </font><font color="#808080"><i>;(1) INLOOP = Accumulator
    </i></font><font color="#000080">wait_start3<b>:         </b></font><font color="#808080"><i>;
      </i></font><font color="#000080">decfsz  inloop<b>,</b>f   </font><font color="#808080"><i>;(1)
      </i></font><font color="#000080">goto    wait_start3</font><font color="#808080"><i>;(2)

      </i></font><font color="#000080">decfsz  outloop<b>,</b>f  </font><font color="#808080"><i>;(1)
      </i></font><font color="#000080">goto    wait_start2</font><font color="#808080"><i>;(2)
                         ;============= end of double loop
                         ; OLval * { ( ILval * 3 ) -1 +5 } -1
                         ; = 3*OLval*ILval + 4*OLval -1
                         ; OLval=ILval=1  ==&gt; 6

    ;test if still startbit,
      </i></font><font color="#000080">btfss  pa<b>,</b></font><font color="#FF0000">pp      </font><font color="#808080"><i>;(2)
      </i></font><font color="#000080">goto   wait_idle  </font><font color="#808080"><i>; if not a start bit anymore, error, seek further

    ;-----------------------------------------------------------------------
    </i></font><font color="#000080">next_bit<b>:
      </b>movfw   OLval      </font><font color="#808080"><i>;(1) Accumulator = Outer Loop Counter
      </i></font><font color="#000080">movwf   outloop    </font><font color="#808080"><i>;(1) OUTLOOP = Accumulator

      ;to optimize for 230 kBaud, we need 22 instructions,
      ;so we still miss 3 instructions
      ;now it will be clear: calling a delay routine isn't possible (4 instructions)
      </i></font><font color="#000080">nop                </font><font color="#808080"><i>;(1)
      </i></font><font color="#000080">goto    next_bit2  </font><font color="#808080"><i>;(2)

    </i></font><font color="#000080">next_bit2<b>:           </b></font><font color="#808080"><i>;=============  start of double loop
      </i></font><font color="#000080">movfw   ILval      </font><font color="#808080"><i>;(1) Accumulator = Inner Loop Counter
      </i></font><font color="#000080">movwf   inloop     </font><font color="#808080"><i>;(1) INLOOP = Accumulator
    </i></font><font color="#000080">next_bit3<b>:           </b></font><font color="#808080"><i>;
      </i></font><font color="#000080">decfsz  inloop<b>,</b>f   </font><font color="#808080"><i>;(1)
      </i></font><font color="#000080">goto    next_bit3  </font><font color="#808080"><i>;(2)

      </i></font><font color="#000080">decfsz  outloop<b>,</b>f  </font><font color="#808080"><i>;(1)
      </i></font><font color="#000080">goto    next_bit2  </font><font color="#808080"><i>;(2)
                         ;============= end of double loop
                         ; OLval * { ( ILval * 3 ) -1 +5 } -1
                         ; = 3*OLval*ILval + 4*OLval -1
                         ; OLval=ILval=1  ==&gt; 6



      ;----- the length of this block is independant of the sampled character
      </i></font><font color="#000080">movfw  pa          </font><font color="#808080"><i>;(1) always sample once and store in buffer SAMP
      </i></font><font color="#000080">movwf  samp        </font><font color="#808080"><i>;(1)
      </i></font><font color="#000080">btfsc  samp<b>,</b></font><font color="#FF0000">pp     </font><font color="#808080"><i>;(1/2) DATA IS INVERTED !!
      </i></font><font color="#000080">bcf    status<b>,</b>C    </font><font color="#808080"><i>;(1/0) clear Carry (will be shifted in data byte)
      </i></font><font color="#000080">btfss  samp<b>,</b></font><font color="#FF0000">pp     </font><font color="#808080"><i>;(2/1)
      </i></font><font color="#000080">bsf    status<b>,</b>C    </font><font color="#808080"><i>;(0/1) set Carry (will be shifted in data byte)
      ;------this block is always (6) instructions

      </i></font><font color="#000080">rrf    x<b>,</b>f         </font><font color="#808080"><i>;(1) shift Carry in result byte


      </i></font><font color="#000080">decfsz bitcnt<b>,</b>f    </font><font color="#808080"><i>;(1) decrement bit count, exit routine if zero
      </i></font><font color="#000080">goto   next_bit    </font><font color="#808080"><i>;(2) continue routine
                         ;(16) without the double loop
                         ; = 3*OLval*ILval + 4*OLval +15
                         ; OLval=ILval=1  ==&gt; 22
    </i></font><b>end </b><font color="#800080"><i>assembler
  </i></font><b>end if
end procedure
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------



-- -----------------------------------------------------------------------------
-- intialisation of value and direction of output pin
-- -----------------------------------------------------------------------------
</i></font><b>procedure </b><font color="#000080">asynch_sw_init_transmit </font><b>is
  </b><font color="#808080"><i>-- set output pin inactive
  </i></font><b>if </b><font color="#FF0000">asynch_invert_sw </font><b>then
   </b><font color="#800080"><i>asm </i></font><font color="#000080">bsf  asynch_sw_out_buffer<b>,</b></font><font color="#FF0000">asynch_sw_out_nr
  </font><b>else
   </b><font color="#800080"><i>asm </i></font><font color="#000080">bcf  asynch_sw_out_buffer<b>,</b></font><font color="#FF0000">asynch_sw_out_nr
  </font><b>end if
  </b><font color="#800080"><i>assembler
     </i></font><font color="#000080">movfw  asynch_sw_out_buffer
     movwf  asynch_sw_out_port
  </font><b>end </b><font color="#800080"><i>assembler
  </i></font><font color="#808080"><i>-- set direction of output pin
  </i></font><font color="#000080">asynch_sw_out_direction <b>= </b></font><font color="#FF0000">output
</font><b>end procedure
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- intialisation of direction of input pin
-- -----------------------------------------------------------------------------
</i></font><b>procedure </b><font color="#000080">asynch_sw_init_receive </font><b>is
  </b><font color="#808080"><i>-- set direction of input pin
  </i></font><font color="#000080">asynch_sw_in_direction <b>= </b></font><font color="#FF0000">input
</font><b>end procedure
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------



</i></font></font>
</code></pre>
</body>
</html>
