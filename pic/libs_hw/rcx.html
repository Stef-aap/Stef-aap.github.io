<HTML><HEAD><TITLE>RCX remote</TITLE>
<STYLE type="text/css"><!--
BODY {
  margin: 5px 5px 5px 5px;
  background-color: #E8E8E8;
}

--></STYLE>
<LINK type="text/css" href="rvf.css" rel=STYLESHEET>
<link rel="icon" href="jalccring_small.gif" type="image/gif"></HEAD>
<BODY>

<P><SPAN class=RVTS1>RCX remote</SPAN></P>
<P><SPAN class=RVTS7>This html document is automatically generated by JALcc, from the JAL-sourcefile</SPAN></P>
<P><SPAN class=RVTS7>rcx.jal&nbsp;&nbsp; 07-08-2004</SPAN></P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>Description&nbsp;</SPAN></P>
<P>Remote control by IR of the RCX&nbsp;</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>Example RCX&nbsp;</SPAN></P>
<P>&nbsp;var volatile bit IR_out is pin_a4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- IR diode&nbsp;</P>
<P>&nbsp;var volatile bit IR_dir is pin_a4_direction -- to set it as an ouput&nbsp;</P>
<P>&nbsp;const bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IR_off =&nbsp; high&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- IR diodes between IO and +5V&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- if IR diodes between IO and GND&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- then set IR_off = low&nbsp;</P>
<P>&nbsp;include RCX&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp; -- motor A forward&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp; RCX_motor_A_on = RCX_motor_on&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp; RCX_motor_A_direction = RCX_motor_forward&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp; RCX_motor_power = RCX_motor_power_A&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp; RCX_update_motor (motor_A)&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;</P>
<P>&nbsp;-- see RCX documentation for more examples&nbsp;</P>
<P>&nbsp;-- program RCX_REMOTE1.JAL is a complete program, with extended remote capabilities&nbsp;</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>License&nbsp;</SPAN></P>
<P>freeware, under the terms of the GNU GPL&nbsp;</P>
<P>Copyright (C) 2002 Stef Mientki&nbsp;</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS1>Version History</SPAN></P>
<P><A class=RVTS4 href="rcx.jal">download&nbsp; rcx.jal</A></P>
<P><A class=RVTS4 href="rcx_source.html">colorcoded HTML&nbsp; rcx_source.html</A></P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>version 1.0&nbsp; somwhere 2002,&nbsp; Stef Mientki&nbsp;</SPAN></P>
<P>- original release&nbsp;</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>Included Files</SPAN></P>
<P>&nbsp;&nbsp;</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS1>Public Procedures</SPAN></P>
<P><SPAN class=RVTS2>procedure interrupt_init</SPAN></P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>procedure IR_send_interrupt_handler</SPAN></P>
<P>-- 38 kHz oscillator/modulator for the IR-transmitter</P>
<P>-- the oscillator is modulated by IR_OUT_BIT,</P>
<P>-- which is manipulated by the program main loop</P>
<P>--</P>
<P>-- timing is based on a 20 Mc X-tal</P>
<P>-- delay fully in timer0 register, to get as less interrupts as possible</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>procedure IR_send_next_bit</SPAN></P>
<P>-- IR send of next bit, sets up the information for the interrupt routine,</P>
<P>-- which does the IR-modulation 38 kHz .. 40 kHz</P>
<P>-- to start, put data in IR_send_byte, set IR_send_bitcnt=0</P>
<P>-- then waiting for IR_send_bitcnt=11 gives 1 stopbit</P>
<P>-- then waiting for IR_send_bitcnt=12 gives 2 stopbits</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>procedure IR_send_next_RCX_byte</SPAN></P>
<P>-- to start:</P>
<P>-- set IR_send_bytecnt to N+1</P>
<P>-- (initially, set IR_send_bitcnt = 0xFF = no start of IR transmitting yet)</P>
<P>--</P>
<P>-- In normal RCX communication as well in remote control commands,</P>
<P>-- all information is transported in a packet.</P>
<P>-- Every command or every complete download is packed in a packet.</P>
<P>-- The packet consists of</P>
<P>--&nbsp; * HEADER, always 55 FF 00 (in receiving the first byte "55" isn't always</P>
<P>--&nbsp;&nbsp;&nbsp; reliable)</P>
<P>--&nbsp; * DATABYTES, where each databyte is followed by it's complement.</P>
<P>--&nbsp;&nbsp;&nbsp; So if you've to send "55 F7", you would have to send "55 AA F7 08"</P>
<P>--&nbsp; * CHECKSUM, that is the sum over all real databytes.</P>
<P>--&nbsp;&nbsp;&nbsp; Also the checksum is followed by its complement !</P>
<P>--&nbsp; IMPORTANT, RCX never executes same exact opcode twice in a row,</P>
<P>--&nbsp; therefor every command has 2 occurences, one with the third bit set and</P>
<P>--&nbsp; the other with third bit reset.</P>
<P>--&nbsp; So you've to toggle this third bit if you want a command sent twice.</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>procedure IR_send_next_RCX_byte2</SPAN></P>
<P>procedure IR_send_next_RCX_byte is</P>
<P>&nbsp; if _IR_send_bitcnt &lt;= 10 then IR_send_next_bit end if</P>
<P>&nbsp;&nbsp;</P>
<P>&nbsp; -- this must be a separate if-loop, because RCX expects only 1 stopbit,</P>
<P>&nbsp; -- on sending the last bit (IR_send_bitcnt = 10 ==&gt; 11),</P>
<P>&nbsp; -- both the previous loop and this loop must be executed</P>
<P>&nbsp; if _IR_send_bitcnt &gt;= 11 then</P>
<P>&nbsp;&nbsp;&nbsp; -- if still more bytes to send, continue</P>
<P>&nbsp;&nbsp;&nbsp; if _IR_send_bytecnt &gt; 0 then</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if _IR_send_bytecnt == 14 then _IR_send_byte = 0x55</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elsif _IR_send_bytecnt == 13 then _IR_send_byte = 0xFF</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elsif _IR_send_bytecnt == 12 then _IR_send_byte = 0x00</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elsif _IR_send_bytecnt == 11 then</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if _last_RCX_cmd == _IR_send_RCX_cmd then</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _IR_send_RCX_cmd = _IR_send_RCX_cmd ^ 0x08</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _last_RCX_cmd = _IR_send_RCX_cmd</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _IR_send_byte = _IR_send_RCX_cmd</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elsif _IR_send_bytecnt == 10 then _IR_send_byte = _IR_send_RCX_cmd ^ 0xFF</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elsif _IR_send_bytecnt == 9 then</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if _IR_send_RCX_narg &gt;= 1 then _IR_send_byte = _IR_send_RCX_arg1</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else _IR_send_bytecnt = 3 end if</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elsif _IR_send_bytecnt == 8 then _IR_send_byte = _IR_send_RCX_arg1 ^ 0xFF</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elsif _IR_send_bytecnt == 7 then</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if _IR_send_RCX_narg &gt;= 2 then _IR_send_byte = _IR_send_RCX_arg2</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else _IR_send_bytecnt = 3 end if</P>
<P>&nbsp;&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elsif _IR_send_bytecnt == 6 then _IR_send_byte = _IR_send_RCX_arg2 ^ 0xFF</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elsif _IR_send_bytecnt == 5 then</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if _IR_send_RCX_narg &gt;= 3 then _IR_send_byte = _IR_send_RCX_arg3</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else _IR_send_bytecnt = 3 end if</P>
<P>&nbsp;&nbsp;</P>
<P>&nbsp;&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elsif _IR_send_bytecnt == 4 then _IR_send_byte = _IR_send_RCX_arg3 ^ 0xFF</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</P>
<P>&nbsp;&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- new test, because in the previous test some states could be jumped over</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if _IR_send_bytecnt == 3 then</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if _IR_send_RCX_narg &gt;= 1 then</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _IR_send_RCX_cmd = _IR_send_RCX_cmd + _IR_send_RCX_arg1</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if _IR_send_RCX_narg &gt;= 2 then</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _IR_send_RCX_cmd = _IR_send_RCX_cmd + _IR_send_RCX_arg2</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if _IR_send_RCX_narg &gt;= 3 then</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _IR_send_RCX_cmd = _IR_send_RCX_cmd + _IR_send_RCX_arg3</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _IR_send_byte = _IR_send_RCX_cmd</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elsif _IR_send_bytecnt == 2 then _IR_send_byte = _IR_send_RCX_cmd ^ 0xFF</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</P>
<P>&nbsp;&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- update byte counter, and start transmission of next byte if not ready</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _IR_send_bytecnt = _IR_send_bytecnt - 1</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if _IR_send_bytecnt &gt; 0 then _IR_send_bitcnt = 0 end if</P>
<P>&nbsp;&nbsp;&nbsp; end if</P>
<P>&nbsp; end if</P>
<P>end procedure</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>function RCX_bittime return bit</SPAN></P>
<P>-- checks if the duration of 1 bit-time is passed</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>procedure RCX_send_command ( byte in RCX_cmd )</SPAN></P>
<P>-- prepares are global variables to send a complete RCX-command</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>procedure RCX_send_command_and_wait ( byte in cmd)</SPAN></P>
<P>-- transmit complete RCX-commandstring and</P>
<P>-- wait till transmission is completed</P>
<P>--</P>
<P>-- it's possible to put these statements into the main program loop,</P>
<P>-- to do something else in the time left (very little),</P>
<P>-- but this is not encouraged, because the timing is very critical</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>procedure RCX_wait_for_respons</SPAN></P>
<P>-- For non-remote commands, the RCX will give a respons. So the next command</P>
<P>-- from the remote control must wait until this respons is finished.</P>
<P>--</P>
<P>-- This routine may be called for other delay purposes.</P>
<P>-- The delay is about 35 msec</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>procedure RCX_update_motor ( byte in motor )</SPAN></P>
</BODY></HTML>
