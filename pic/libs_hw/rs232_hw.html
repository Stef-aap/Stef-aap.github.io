<HTML><HEAD><TITLE>USART hardware control</TITLE>
<STYLE type="text/css"><!--
BODY {
  margin: 5px 5px 5px 5px;
  background-color: #E8E8E8;
}

--></STYLE>
<LINK type="text/css" href="rvf.css" rel=STYLESHEET>
<link rel="icon" href="jalccring_small.gif" type="image/gif"></HEAD>
<BODY>

<P><SPAN class=RVTS1>USART hardware control</SPAN></P>
<P><SPAN class=RVTS7>This html document is automatically generated by JALcc, from the JAL-sourcefile</SPAN></P>
<P><SPAN class=RVTS7>rs232_hw.jal&nbsp;&nbsp; 05-08-2004</SPAN></P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>Description&nbsp;</SPAN></P>
<P>USART hardware control.&nbsp;</P>
<P>Routines for sending and receiving through the PIC-usart, both RS232 and SPI are supported&nbsp;</P>
<P>Baudrate can simply be set through a human constant, because the baudrate depending registers are calculated by this unit.&nbsp;</P>
<P>Baudrate is calculated, starting at the high baudrate flag, which will ensure the highest possible accuracy.&nbsp;</P>
<P>SPI routines are setup for more SPI-devices, in which case CS should be controled outside this unit.&nbsp;</P>
<P>Transmission parameters are 8 databits, 1 stopbit, no parity, no handshake.&nbsp;</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>Example RS232&nbsp;</SPAN></P>
<P>&nbsp;-- define settings&nbsp;</P>
<P>&nbsp;const usart_asynch = true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;true = RS232, false = SPI&nbsp;</P>
<P>&nbsp;const baudrate&nbsp;&nbsp;&nbsp;&nbsp; = 115_200&nbsp;&nbsp; ;Baudrate&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;</P>
<P>&nbsp;var byte xx&nbsp;</P>
<P>&nbsp;forever loop&nbsp;</P>
<P>&nbsp;&nbsp; -- if character received, echo inverted&nbsp;</P>
<P>&nbsp;&nbsp; if asynch_read_hw (xx) then&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; asynch_send_hw ( ! xx)&nbsp;</P>
<P>&nbsp;&nbsp; end if&nbsp;</P>
<P>&nbsp;&nbsp; ... do other things here&nbsp;</P>
<P>&nbsp;end loop&nbsp;</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>License&nbsp;</SPAN></P>
<P>freeware, under the terms of the GNU GPL&nbsp;</P>
<P>Copyright (C) 2002 Stef Mientki&nbsp;</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS1>Version History</SPAN></P>
<P><A class=RVTS4 href="rs232_hw.jal">download&nbsp; rs232_hw.jal</A></P>
<P><A class=RVTS4 href="rs232_hw_source.html">colorcoded HTML&nbsp; rs232_hw_source.html</A></P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>Version: 3.0&nbsp;&nbsp;&nbsp; ,21-08-2002, Stef Mientki&nbsp;</SPAN></P>
<P>- INTCON clearing removed, blocked all interrupts,&nbsp;</P>
<P>instead PIE bits cleared to prevent USART interrupts&nbsp;</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>Version: 2.0&nbsp;&nbsp;&nbsp; ,21-06-2002, Stef Mientki&nbsp;</SPAN></P>
<P>- added Procedure ASYNCH_DISABLE_HW&nbsp;</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>Version: 1.0&nbsp;&nbsp;&nbsp; ,17-03-2002, Stef Mientki&nbsp;</SPAN></P>
<P>- original release&nbsp;</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>Included Files</SPAN></P>
<P>&nbsp;&nbsp;</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS1>Public Procedures</SPAN></P>
<P><SPAN class=RVTS2>procedure SPI_init</SPAN></P>
<P>-- Initializes the SPI port, calculates baudrate registers.</P>
<P>-- Normally this routine should not be called by the user program,</P>
<P>-- it's called once at the end of this unit.</P>
<P>-- Only after "asynch_disable_hw" it's necessary to call this routine,</P>
<P>-- to enable the SPI hardware again.</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>procedure asynch_init_hw</SPAN></P>
<P>-- Initializes the RS232 port, calculates baudrate registers.</P>
<P>-- Normally this routine should not be called by the user program,</P>
<P>-- it's called just once at the end of this unit</P>
<P>-- Only after "asynch_disable_hw" it's necessary to call this routine,</P>
<P>-- to enable the RS232 hardware again.</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>procedure asynch_disable_hw</SPAN></P>
<P>-- Disables USART (wether used as RS232 or SPI),</P>
<P>-- so ports can be used (temporary) for other purposes.</P>
<P>-- USART can be enabled again by calling&nbsp;&nbsp; asynch_init_hw&nbsp; or&nbsp; SPI_init_hw</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>procedure asynch_send_hw ( byte in x )</SPAN></P>
<P>-- Asynchronuous RS232 send routine, using the TX pin</P>
<P>-- Sends byte X (8 bit with no parity) to the serial port</P>
<P>-- First checks (and waits if necessary) if transmit buffer is empty</P>
<P>--</P>
<P>-- remark: PIR1-register (containing _TXIF-flag) must be in bank0 !!</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>function asynch_read_hw ( byte out x ) return bit</SPAN></P>
<P>-- Returns truw if a character was received, otherwise returns false.</P>
<P>-- Overrun error flag is cleared.</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>procedure SPI_send_hw ( byte in x )</SPAN></P>
<P>-- SPI send routine, using the TX pin</P>
<P>-- Sends byte X (8 bit with no parity) to the serial port</P>
<P>-- After sending the byte, this routine will wait till byte is really transmitted.</P>
<P>-- This is done in order to be able to use CS for multiple SPI-devices.</P>
<P>--</P>
<P>-- remark: PIR1-register (containing _TXIF-flag) must be in bank0 !!</P>
<P>&nbsp;&nbsp;</P>
<P><SPAN class=RVTS2>procedure SPI_read_hw ( byte out x )</SPAN></P>
<P>-- reads a byte from the SPI-bus</P>
<P>-- After reception, all error flags are cleared</P>
</BODY></HTML>
