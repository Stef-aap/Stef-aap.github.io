<html>
<head>
<title>JALcc SourceCode exporting of dallas_1_wire_source.html</title>
</head>
<!-- Generated by SynEdit HTML exporter -->
<body text="#000000" bgcolor="#FFFFFF">
<pre>
<code><font  size=3 face="Courier New"><font color="#000000"><A href="dallas_1_wire.jal">download&nbsp;dallas_1_wire.jal</A>
<font color="#808080"><i>-- -----------------------------------------------------------------------------
-- &lt;title Dallas 1-wire bus JAL library
-- specially for the DS18B20
--
-- &lt;License
-- freeware, under the terms of the GNU/GPL  
--  , Copyright (C) 2004 Stef Mientki  
--
-- &lt;Description
-- JAL library for control of Dallas 1-wire bus and specially the DS18B20.
--  The serach algorithm is based on:
--       http://pdfserv.maxim-ic.com/en/an/app187.pdf
--  the basic 1-wire routines are based on
--       previous libs from Philip Pemberton and Vasile Surducan (thanks!)
--
-- interface
--    function Dallas_1_wire_get_devices_all
--		procedure DS18B20_set_resolution_and_alarms
--		procedure DS18B20_get_resolution_and_alarms
-- 		procedure DS18B20_load_settings_from_EEprom
-- 		procedure DS18B20_save_settings_to_EEprom
--		procedure DS18B20_start_conversion 
--		procedure DS18B20_get_raw_temperature 
--
--    globals:  
--       Dallas_1_wire_device_count
--		   ROM-codes of the found devices are stored in ARRAY3
--
--
-- &lt;Version: 1.2    ,12-01-2005, Stef Mientki
--      - bug fixed, no more then 2 sensors could be detected, otherwise hanged
--			- 1-wire device ROM-codes moved to array3, which gives room for 12 devices
--			- array1 is needed to store temporary ROM-codes
--
-- &lt;Version: 1.1    ,10-09-2004, Stef Mientki
--      - added procedure DS18B20_get_raw_temperature_nowait
--
-- &lt;Version: 1.0    ,10-07-2004, Stef Mientki
--    - orginal release
--
-- -----------------------------------------------------------------------------
-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- &lt;Example 
-- -----------------------------------------------------------------------------
; const array_check_indices = false
;
; const array0_start = 0x70       -- no array in bank 0 wanted
; const array0_end   = 0x6F       --   so make end-index smaller than start_index
; -- the first 8 positions of bank1 are used to store ROM_NO
; const array1_start = 0xA0
; const array1_end   = 0xEF
; const array2_start = 0x120
; const array2_end   = 0x11F
; -- bank3 is used completly (except the common registers at the end)
; -- so that gives room for a maximum of 12 pieces of 1-wire devices
; const array3_start = 0x190
; const array3_end   = 0x1EF
;
; -- include the ARRAY implementation
; include bank_arrays
;
; -- Temperature sensors
; &lt;mac&gt; io_pin	    _1_wire = pin_d0
; include DS18B20
; var byte Tmsb, Tlsb
;
; -- Start a search for all 1-wire devices
; Dallas_1_wire_get_devices_all
; -- Display the number of found devices
; asynch_send_hw (Dallas_1_wire_device_count)
;
; -- Display the ROM-code of all devices
; array3_get_index = 0
; for Dallas_1_wire_device_count loop
;   for 8 loop
;     asynch_send_hw (array3)
;   end loop
; end loop
; 
; forever loop
;   -- start temperature measurement for all devices
;   DS18B20_start_conversion
;   -- get the temperature of the first sensor
;   DS18B20_get_raw_temperature (1, Tmsb, Tlsb)
;   -- display the temperature detected by the first sensor
;   asynch_send_hw(Tmsb)
;   asynch_send_hw(Tlsb)
;   -- now the same for the second sensor
;   DS18B20_get_raw_temperature (2, Tmsb, Tlsb)
;   asynch_send_hw(Tmsb)
;   asynch_send_hw(Tlsb)
; end loop
-- -----------------------------------------------------------------------------


-- &lt;code

-- include the implementation
</i></font><b>include </b>bank_arrays
<b>include </b>delay_20Mc

<font color="#808080"><i>-- -----------------------------------------------------------------------------
-- some global variables, needed for the search algorithm
-- -----------------------------------------------------------------------------
</i></font><b>var byte </b>LastDiscrepancy 
<b>var byte </b>LastFamilyDiscrepancy
<b>var bit  </b>LastDeviceFlag
<b>var volatile byte </b>Dallas_1_wire_device_count



<font color="#808080"><i>-- 1-wire ROM commands
</i></font><b>const byte </b><font color="#FF0000"><b>_1_wire_search_ROM            </b></font>= <font color="#FF0000"><b>0xF0
</b></font><b>const byte </b><font color="#FF0000"><b>_1_wire_read_rom              </b></font>= <font color="#FF0000"><b>0x33
</b></font><b>const byte </b><font color="#FF0000"><b>_1_wire_match_rom             </b></font>= <font color="#FF0000"><b>0x55
</b></font><b>const byte </b><font color="#FF0000"><b>_1_wire_skip_rom              </b></font>= <font color="#FF0000"><b>0xCC
</b></font><b>const byte </b><font color="#FF0000"><b>_1_wire_alarm_search          </b></font>= <font color="#FF0000"><b>0xEC

</b></font><font color="#808080"><i>-- DS18B20 Function commands
</i></font><b>const byte </b><font color="#FF0000"><b>_cmd_DS18B20_convert_T        </b></font>= <font color="#FF0000"><b>0x44
</b></font><b>const byte </b><font color="#FF0000"><b>_cmd_DS18B20_write_scratchpad </b></font>= <font color="#FF0000"><b>0x4E
</b></font><b>const byte </b><font color="#FF0000"><b>_cmd_DS18B20_read_scratchpad</b></font><font color="#000080"><b>	 </b></font>= <font color="#FF0000"><b>0xBE
</b></font><b>const byte </b><font color="#FF0000"><b>_cmd_DS18B20_copy_scratchpad</b></font><font color="#000080"><b>	 </b></font>= <font color="#FF0000"><b>0x48
</b></font><b>const byte </b><font color="#FF0000"><b>_cmd_DS18B20_recall_E2        </b></font>= <font color="#FF0000"><b>0xB8
</b></font><b>const byte </b><font color="#FF0000"><b>_cmd_DS18B20_read_powersupply </b></font>= <font color="#FF0000"><b>0xB4


</b></font><font color="#808080"><i>-- -----------------------------------------------------------------------------
-- generates a reset on the 1-wire bus
-- and tests if 1-wire devices available
-- returns 
--   0 = ok, devices present
--	 1 = ok, but no devices present
--	 2 = error, bus short circuited to ground
-- independant of PIC-speed and no false triggering by spikes
-- -----------------------------------------------------------------------------
</i></font><b>function </b>_1_wire_reset <b>return byte is
var byte </b>present_count
  <font color="#808080"><i>-- see if pin not short circuited to ground
  </i></font>_1_wire_direction = <font color="#FF0000"><b>input
  </b></font><b>if </b>! _1_wire_pin <b>then return </b><font color="#FF0000"><b>2 </b></font><b>end if
  
  </b><font color="#808080"><i>-- reset puls &gt; 480 usec
  </i></font>_1_wire_direction = <font color="#FF0000"><b>output
  </b></font>delay_10us(<font color="#FF0000"><b>50</b></font>)            
  _1_wire_direction = <font color="#FF0000"><b>input        
  
  </b></font><font color="#808080"><i>-- now check if presence puls (low) on the interval 60 .. 75 usec
  </i></font>delay_10us(<font color="#FF0000"><b>6</b></font>)
  present_count = <font color="#FF0000"><b>0
  </b></font><font color="#808080"><i>-- DS18B20 returns present_count = 12..13 (on loop=20) 
  </i></font><b>for </b><font color="#FF0000"><b>10 </b></font><b>loop
    if </b>! _1_wire_pin <b>then </b>present_count = present_count + <font color="#FF0000"><b>1 </b></font><b>end if
    </b>delay_4us
  <b>end loop
  
  </b><font color="#808080"><i>-- master has to wiat at least 480 us after a reset
  </i></font>delay_10us (<font color="#FF0000"><b>40</b></font>)
  
  <font color="#808080"><i>-- if long enough low present pulse detected
  </i></font><b>if </b>present_count &gt;= <font color="#FF0000"><b>3 </b></font><b>then
    return </b><font color="#FF0000"><b>0                            </b></font><font color="#808080"><i>-- Yes - return with errorcode 0
  </i></font><b>else
    return </b><font color="#FF0000"><b>1                            </b></font><font color="#808080"><i>-- No - return with errorcode 1
  </i></font><b>end if
end function
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- Write 1 bit to the 1-Wire bus and completes the write-slot
-- -----------------------------------------------------------------------------
</i></font><b>procedure </b>_1_wire_writebit (<b>bit in </b>wb) <b>is
  </b><font color="#808080"><i>-- start with pulling 1-wire line down
  </i></font>_1_wire_direction = <font color="#FF0000"><b>output
  </b></font><b>if </b>wb <b>then
    </b><font color="#808080"><i>-- Output a &quot;1&quot;, min 1 usec low, min 60 usec high
    </i></font>delay_2us
    _1_wire_direction = <font color="#FF0000"><b>input
    </b></font>delay_10us(<font color="#FF0000"><b>6</b></font>)
  <b>else
    </b><font color="#808080"><i>-- Output a &quot;0&quot;, min 60 usec low, min 1 usec float
    </i></font>delay_10us(<font color="#FF0000"><b>6</b></font>)
    _1_wire_direction = <font color="#FF0000"><b>input
    </b></font>delay_2us
  <b>end if
end procedure
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- Read 1 bit from the 1-Wire bus, and completes the read slot
-- -----------------------------------------------------------------------------
</i></font><b>function </b>_1_wire_readbit <b>return bit is
var bit </b>temp
  <font color="#808080"><i>-- start read slot, min 1 usec low
  </i></font>_1_wire_direction = <font color="#FF0000"><b>output
  </b></font>delay_2us
  _1_wire_direction = <font color="#FF0000"><b>input

  </b></font><font color="#808080"><i>-- now master should sample before 15usec-2usec has passed
  </i></font>delay_10us
  temp = _1_wire_pin

  <font color="#808080"><i>-- now complete the timeslot, till at least 60 usec
  </i></font>delay_10us(<font color="#FF0000"><b>5</b></font>)

  <b>return </b>temp
<b>end function
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- Write 1 byte to the 1-Wire bus
-- -----------------------------------------------------------------------------
</i></font><b>procedure </b>_1_wire_writebyte (<b>byte in </b>wb) <b>is
  for </b><font color="#FF0000"><b>8 </b></font><b>loop
    </b><font color="#808080"><i>-- start with lsb
    </i></font><font color="#800080"><i>asm </i></font>rrf wb,f
    _1_wire_writebit(C)
  <b>end loop
end procedure
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- Read 1 byte from the 1-Wire bus
-- -----------------------------------------------------------------------------
</i></font><b>function </b>_1_wire_readbyte <b>return byte is
var byte </b>temp
  <b>for </b><font color="#FF0000"><b>8 </b></font><b>loop
    </b>C = _1_wire_readbit
    <font color="#800080"><i>asm </i></font>rrf temp, f
  <b>end loop
  return </b>temp
<b>end function
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- Perform the 1-Wire Search Algorithm on the 1-Wire bus using the current
-- search state, definied by LastDiscrepancy, LastFamilyDiscrepancy, LastDeviceFlag
-- The resulting ROM-codes are stored in ram: ARRAY3
-- Return TRUE  : device found, ROM number is placed in ARRAY3
--        FALSE : device not found, end of search
--
-- This function is prepared for family search, but it's not yet implemented.
-- CRC is not checked, because it consumes too much resources.
-- -----------------------------------------------------------------------------
</i></font><b>function </b>_1_wire_Search <b>return bit is
var byte </b>id_bit_number
<b>var byte </b>last_zero
<b>var bit  </b>id_bit
<b>var bit  </b>cmp_id_bit 
<b>var byte </b>rom_byte_mask
<b>var bit  </b>search_direction
<b>var byte </b>rom_byte_number

   <font color="#808080"><i>-- initialize for search
   </i></font>id_bit_number = <font color="#FF0000"><b>1
   </b></font>last_zero = <font color="#FF0000"><b>0
   </b></font>rom_byte_mask = <font color="#FF0000"><b>1

  </b></font><font color="#808080"><i>-- if the last call was not the last one
  </i></font><b>if </b>LastDeviceFlag <b>then return </b><font color="#FF0000"><b>false
  </b></font><b>else
    </b><font color="#808080"><i>-- if reset fails, return false
</i></font><font color="#000080"><b>		</b></font><b>if </b>_1_wire_reset != <font color="#FF0000"><b>0 </b></font><b>then  return </b><font color="#FF0000"><b>FALSE </b></font><b>end if
    </b><font color="#808080"><i>-- issue the search command 
    </i></font>_1_wire_writebyte (<font color="#FF0000"><b>_1_wire_search_ROM</b></font>)

    <font color="#808080"><i>-- loop for all 64 bits (8*8 bytes)
</i></font><font color="#000080"><b>		</b></font>rom_byte_number = <font color="#FF0000"><b>0
</b></font><font color="#000080"><b>		</b></font><b>while </b>rom_byte_number &lt; <font color="#FF0000"><b>8 </b></font><b>loop
      </b><font color="#808080"><i>-- read a bit and its complement
      </i></font>id_bit = _1_wire_readbit    
      cmp_id_bit = _1_wire_readbit    
      <font color="#808080"><i>-- check for no devices on 1-wire
      </i></font><b>if </b>id_bit &amp; cmp_id_bit <b>then return </b><font color="#FF0000"><b>false
      </b></font><b>else
        </b><font color="#808080"><i>-- all devices coupled have 0 or 1
        </i></font><b>if </b>id_bit != cmp_id_bit <b>then
          </b>search_direction = id_bit   <font color="#808080"><i>; bit write value for search
        </i></font><b>else
          </b><font color="#808080"><i>-- if this discrepancy if before the Last Discrepancy
          -- on a previous next then pick the same as last time
          </i></font><b>if </b>id_bit_number &lt; LastDiscrepancy <b>then
</b><font color="#000080"><b>						</b></font>array1_get_index = rom_byte_number<font color="#808080"><i>;
</i></font><font color="#000080"><b>						</b></font>search_direction = (array1 &amp; rom_byte_mask) != <font color="#FF0000"><b>0
          </b></font><b>else
            </b><font color="#808080"><i>-- if equal to last pick 1, if not then pick 0
            </i></font>search_direction = (id_bit_number == LastDiscrepancy)<font color="#808080"><i>;
          </i></font><b>end if
          </b><font color="#808080"><i>-- if 0 was picked then record its position in LastZero
          </i></font><b>if </b>! search_direction <b>then
            </b>last_zero = id_bit_number<font color="#808080"><i>;
            -- check for Last discrepancy in family
            </i></font><b>if </b>last_zero &lt; <font color="#FF0000"><b>9 </b></font><b>then
              </b>LastFamilyDiscrepancy = last_zero<font color="#808080"><i>;
            </i></font><b>end if
          end if
        end if
        </b><font color="#808080"><i>-- set or clear the bit in the result byte 
        -- with mask rom_byte_mask
</i></font><font color="#000080"><b>				</b></font>array1_get_index = rom_byte_number<font color="#808080"><i>;
</i></font><font color="#000080"><b>				</b></font>array1_put_index = rom_byte_number<font color="#808080"><i>;
</i></font><font color="#000080"><b>				</b></font><b>if </b>search_direction <b>then
</b><font color="#000080"><b>					</b></font>array1 = array1 | rom_byte_mask
<font color="#000080"><b>				</b></font><b>else
</b><font color="#000080"><b>					</b></font>array1 = array1 &amp; (! rom_byte_mask)
<font color="#000080"><b>				</b></font><b>end if
        </b><font color="#808080"><i>-- serial number search direction write bit
</i></font><font color="#000080"><b> 				</b></font>_1_wire_writebit (search_direction)
        <font color="#808080"><i>-- increment the byte counter id_bit_number
        -- and shift the mask rom_byte_mask
        </i></font>id_bit_number = id_bit_number + <font color="#FF0000"><b>1
        </b></font>rom_byte_mask = rom_byte_mask &lt;&lt; <font color="#FF0000"><b>1
        </b></font><font color="#808080"><i>-- if the mask is 0 then go to new SerialNum byte result byte and reset mask
        </i></font><b>if </b>rom_byte_mask == <font color="#FF0000"><b>0 </b></font><b>then
          </b>array1_get_index = rom_byte_number<font color="#808080"><i>;
          </i></font>array3 = array1  <font color="#808080"><i>;store the result in array3 and increment pointer
          </i></font>rom_byte_number = rom_byte_number + <font color="#FF0000"><b>1
          </b></font>rom_byte_mask = <font color="#FF0000"><b>1
        </b></font><b>end if
      end if
    end loop

    </b><font color="#808080"><i>-- if the search was successful then
    -- search successful so set LastDiscrepancy,LastDeviceFlag,search_result
    </i></font>LastDiscrepancy = last_zero<font color="#808080"><i>;
    -- check for last device
    </i></font><b>if </b>LastDiscrepancy == <font color="#FF0000"><b>0 </b></font><b>then
      </b>LastDeviceFlag = <font color="#FF0000"><b>TRUE</b></font><font color="#808080"><i>;
    </i></font><b>end if
  end if
  return </b><font color="#FF0000"><b>true
</b></font><b>end function
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- Addresses one or all of the devices on the 1-wire bus
-- The ROM codes of the devices should be available in array bank ARRAY
-- Device_index=0 (default) addresses all the devices.
-- Before addressing is performed, the 1-wire bus is reset.
-- -----------------------------------------------------------------------------
</i></font><b>procedure </b>_1_wire_address_device (<b>byte in </b>device_index = <font color="#FF0000"><b>0</b></font>) <b>is
var byte </b>x
  _1_wire_reset
  <b>if </b>device_index == <font color="#FF0000"><b>0 </b></font><b>then
    </b>_1_wire_writebyte (<font color="#FF0000"><b>_1_wire_skip_rom</b></font>)
  <b>else
    </b>_1_wire_writebyte (<font color="#FF0000"><b>_1_wire_match_rom</b></font>)

    <font color="#808080"><i>-- now write the ROM code of the selected device to the 1-wire bus
    </i></font>array3_get_index = (device_index - <font color="#FF0000"><b>1</b></font>) &lt;&lt; <font color="#FF0000"><b>3
    </b></font><b>for </b><font color="#FF0000"><b>8 </b></font><b>loop
      </b>_1_wire_writebyte (array3)
    <b>end loop
  end if
end procedure
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- This procedure searches for all devices on the 1-wire-bus
-- returns the number of devices
-- the number of devices is stored in the global Dallas_1_wire_device_count
-- the RM-code of the devices are stored in the global array ARRAY3
-- The addressing of the sensors in all other routines is done by an index
-- to the array ARRAY3 [1.. 8*Dallas_1_wire_device_count].
-- Each device occupies 8 bytes in the ARRAY3
-- Index=0 means all devices !!
-- -----------------------------------------------------------------------------
</i></font><b>function </b>Dallas_1_wire_get_devices_all 
  <b>return byte is
var bit  </b>found
  <font color="#808080"><i>-- reset the search state

</i></font><font color="#000080"><b>	</b></font><font color="#808080"><i>-- clear ROM_NO array
</i></font><font color="#000080"><b>	</b></font>array1_put_index = <font color="#FF0000"><b>0
</b></font><font color="#000080"><b>	</b></font><b>for </b><font color="#FF0000"><b>8 </b></font><b>loop
</b><font color="#000080"><b>		</b></font>array1 = <font color="#FF0000"><b>0
</b></font><font color="#000080"><b>	</b></font><b>end loop

  </b>LastDiscrepancy = <font color="#FF0000"><b>0
  </b></font>LastDeviceFlag = <font color="#FF0000"><b>FALSE
  </b></font>LastFamilyDiscrepancy = <font color="#FF0000"><b>0
  </b></font>array3_put_index = <font color="#FF0000"><b>0

  </b></font>found = _1_wire_Search
  Dallas_1_wire_device_count = <font color="#FF0000"><b>0
  </b></font><b>while </b>found <b>loop
    </b>Dallas_1_wire_device_count = Dallas_1_wire_device_count + <font color="#FF0000"><b>1
    </b></font>found = _1_wire_Search
  <b>end loop
  return </b>Dallas_1_wire_device_count
<b>end function
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- This procedure searches for ONE DS18B20 device on the 1-wire-bus, 
-- the 8 bytes ROM-code-ID is stored in ARRAY3
--  In case you hardcode the device ID's in software, 
-- this routine can be used to identify just one device.
--  If more devices are available on the bus, the device with the most significant
-- zeroes will be identified.
-- -----------------------------------------------------------------------------
;function DS18B20_get_device_ID return byte is
;var bit b1,b2
;var byte kar
;
;  -- if devices present, try to indentify them
;  if _1_wire_reset == 0 then
;    _1_wire_writebyte (_1_wire_search_ROM)
;    for 8 loop
;      for 8 loop
;	      b1 = _1_wire_readbit
;        b2 = _1_wire_readbit
;        _1_wire_writebit (b1)
;        -- store bit in kar
;        C = b1
;  			asm rrf kar,f
;      end loop
;      -- on byte completion, store byte in array and incremenet pointer
;      array3 = kar
;    end loop
;  end if
;end function
-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- Sets resolution and alarms into the selected devices.
-- NOTE, if internal alarms are not used,
-- these locations can be used to store (permanently) other information.
-- Resolution must be specified in &quot;human&quot; indices, i.e. 9,10,11,12
-- After settings are done, the values can be stored permantly in the eeprom 
-- of the device by the procedure DS18B20_save_settings_to_EEprom.
-- (device_index=0 means all devices)
-- -----------------------------------------------------------------------------
</i></font><b>procedure </b>DS18B20_set_resolution_and_alarms
  (<b>byte in </b>device_index = <font color="#FF0000"><b>0</b></font>,
<font color="#000080"><b>	 </b></font><b>byte in </b>Resolution = <font color="#FF0000"><b>12</b></font>,
   <b>byte in </b>Talarm_high,
   <b>byte in </b>Talarm_low) <b>is

  </b>_1_wire_address_device (device_index)
  _1_wire_writebyte (<font color="#FF0000"><b>_cmd_DS18B20_write_scratchpad</b></font>)
  _1_wire_writebyte (Talarm_high)
  _1_wire_writebyte (Talarm_low)
  <b>if </b>Resolution &lt; <font color="#FF0000"><b>9 </b></font><b>then </b>Resolution = <font color="#FF0000"><b>9
  </b></font><b>elsif </b>resolution &gt; <font color="#FF0000"><b>12 </b></font><b>then </b>Resolution = <font color="#FF0000"><b>12
  </b></font><b>end if
  </b>Resolution = ((Resolution - <font color="#FF0000"><b>9</b></font>) &lt;&lt; <font color="#FF0000"><b>5</b></font>) | <font color="#FF0000"><b>0x1F
  </b></font>_1_wire_writebyte (Resolution)
<b>end procedure
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- Reads resolution and alarms from the selected devices.
-- Resolution is translated to &quot;human&quot; indices, i.e. 9,10,11,12
-- Index=0 means all devices !! (this is not meaningfull !!)
-- -----------------------------------------------------------------------------
</i></font><b>procedure </b>DS18B20_get_resolution_and_alarms
  (<b>byte in </b>device_index,
<font color="#000080"><b>	 </b></font><b>byte out </b>Resolution,
   <b>byte out </b>Talarm_high,
   <b>byte out </b>Talarm_low) <b>is
var bit </b>b1
  _1_wire_address_device (device_index)
  _1_wire_writebyte (<font color="#FF0000"><b>_cmd_DS18B20_read_scratchpad</b></font>)
  Talarm_high = _1_wire_readbyte   <font color="#808080"><i>;ignore temperature values 
  </i></font>Talarm_high = _1_wire_readbyte    
  Talarm_high = _1_wire_readbyte    
  Talarm_low = _1_wire_readbyte    
  Resolution = ((_1_wire_readbyte &amp; <font color="#FF0000"><b>0b_0110_0000</b></font>) &gt;&gt; <font color="#FF0000"><b>5</b></font>)+ <font color="#FF0000"><b>9
</b></font><b>end procedure
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- loads alarm and resolution settings from the EEprom into the device's scratchpad
-- -----------------------------------------------------------------------------
</i></font><b>procedure </b>DS18B20_load_settings_from_EEprom 
  (<b>byte in </b>device_index = <font color="#FF0000"><b>0</b></font>) <b>is
  </b>_1_wire_address_device (device_index)
  _1_wire_writebyte (<font color="#FF0000"><b>_cmd_DS18B20_recall_E2</b></font>)
<b>end procedure
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- saves alarm and resolution settings from the device's scratchpad to the EEprom
-- -----------------------------------------------------------------------------
</i></font><b>procedure </b>DS18B20_save_settings_to_EEprom 
  (<b>byte in </b>device_index = <font color="#FF0000"><b>0</b></font>) <b>is
  </b>_1_wire_address_device (device_index)
  _1_wire_writebyte (<font color="#FF0000"><b>_cmd_DS18B20_copy_scratchpad</b></font>)
<b>end procedure
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- Starts the temperature conversion for the selected device.
-- (device_index=0 means all devices)
-- -----------------------------------------------------------------------------
</i></font><b>procedure </b>DS18B20_start_conversion 
  (<b>byte in </b>device_index = <font color="#FF0000"><b>0</b></font>) <b>is
  </b>_1_wire_address_device (device_index)
  _1_wire_writebyte (<font color="#FF0000"><b>_cmd_DS18B20_convert_T</b></font>)
<b>end procedure
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- Reads the temperature from the selected device.
-- same as DS18B20_get_raw_temperature, (see below)
-- except it doesn't wait.
-- In cases where it's ensured that the conversion time of the sensor is satisfied,
-- this procedure has the advantage that it doesn't hang for a while,
-- in case something is wrong with the sensors
-- -----------------------------------------------------------------------------
</i></font><b>procedure </b>DS18B20_get_raw_temperature_nowait
  (<b>byte in </b>device_index ,
   <b>byte out </b>Tmsb,
   <b>byte out </b>Tlsb) <b>is
var bit </b>b1
  _1_wire_address_device (device_index)
  _1_wire_writebyte (<font color="#FF0000"><b>_cmd_DS18B20_read_scratchpad</b></font>)
  Tlsb = _1_wire_readbyte    
  Tmsb = _1_wire_readbyte    
<b>end procedure
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- Reads the temperature from the selected device.
-- device_index=0 reads all the sensors and stores them in array ...
--   in that case temp_high and temp_low will contain the temparture from the first sensor
-- IMPORTANT reading of each sensor takes about 4 msec !!
-- In case a temerature measurement is still in progress, the procedure waits.
-- -----------------------------------------------------------------------------
</i></font><b>procedure </b>DS18B20_get_raw_temperature 
  (<b>byte in </b>device_index ,
   <b>byte out </b>Tmsb,
   <b>byte out </b>Tlsb) <b>is
var bit </b>b1
  <font color="#808080"><i>-- to be sure, wait for DS18B20 to be ready
  </i></font>b1 = <font color="#FF0000"><b>false 
  </b></font><b>while </b>! b1 <b>loop
    </b>b1 = _1_wire_readbit
  <b>end loop

  </b>DS18B20_get_raw_temperature_nowait(device_index, Tmsb, Tlsb)
<b>end procedure
</b><font color="#808080"><i>-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- initialize
-- -----------------------------------------------------------------------------
</i></font>_1_wire_direction = <font color="#FF0000"><b>input
</b></font>_1_wire_pin<font color="#000080"><b>				</b></font>= <b>low


</b></font>
</code></pre>
</body>
</html>
